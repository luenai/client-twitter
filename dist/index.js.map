{"version":3,"sources":["../src/client.ts","../src/base.ts","../src/environment.ts","../src/interactions.ts","../src/utils.ts","../src/post.ts","../src/search.ts","../src/spaces.ts","../src/plugins/SttTtsSpacesPlugin.ts","../src/plugins/templates.ts","../src/index.ts"],"sourcesContent":["import { type Client, elizaLogger, type IAgentRuntime, type Plugin } from \"@elizaos/core\";\nimport { ClientBase } from \"./base.ts\";\nimport { validateTwitterConfig, type TwitterConfig } from \"./environment.ts\";\nimport { TwitterInteractionClient } from \"./interactions.ts\";\nimport { TwitterPostClient } from \"./post.ts\";\nimport { TwitterSearchClient } from \"./search.ts\";\nimport { TwitterSpaceClient } from \"./spaces.ts\";\nimport {getTokensForUser} from \"./redisHelper.ts\";\n\n/**\n * A manager that orchestrates all specialized Twitter logic:\n * - client: base operations (login, timeline caching, etc.)\n * - post: autonomous posting logic\n * - search: searching tweets / replying logic\n * - interaction: handling mentions, replies\n * - space: launching and managing Twitter Spaces (optional)\n */\nclass TwitterManager {\n    client: ClientBase;\n    post: TwitterPostClient;\n    search: TwitterSearchClient;\n    interaction: TwitterInteractionClient;\n    space?: TwitterSpaceClient;\n\n    constructor(runtime: IAgentRuntime, twitterConfig: TwitterConfig) {\n        // Pass twitterConfig to the base client\n        this.client = new ClientBase(runtime, twitterConfig);\n\n        // Posting logic\n        this.post = new TwitterPostClient(this.client, runtime);\n\n        // Optional search logic (enabled if TWITTER_SEARCH_ENABLE is true)\n        if (twitterConfig.TWITTER_SEARCH_ENABLE) {\n            elizaLogger.warn(\"Twitter/X client running in a mode that:\");\n            elizaLogger.warn(\"1. violates consent of random users\");\n            elizaLogger.warn(\"2. burns your rate limit\");\n            elizaLogger.warn(\"3. can get your account banned\");\n            elizaLogger.warn(\"use at your own risk\");\n            this.search = new TwitterSearchClient(this.client, runtime);\n        }\n\n        // Mentions and interactions\n        this.interaction = new TwitterInteractionClient(this.client, runtime);\n\n        // Optional Spaces logic (enabled if TWITTER_SPACES_ENABLE is true)\n        if (twitterConfig.TWITTER_SPACES_ENABLE) {\n            this.space = new TwitterSpaceClient(this.client, runtime);\n        }\n    }\n\n    async stop() {\n        elizaLogger.warn(\"Twitter client does not support stopping yet\");\n    }\n}\n\nexport const TwitterClientInterface: Client = {\n    name: 'twitter',\n    async start(runtime: IAgentRuntime) {\n        const twitterConfig: TwitterConfig =\n            await validateTwitterConfig(runtime);\n\n        elizaLogger.log(\"Twitter client started\");\n\n        const manager = new TwitterManager(runtime, twitterConfig);\n\n        // Initialize login/session\n        await manager.client.init();\n\n        // Start the posting loop\n        await manager.post.start();\n\n        // Start the search logic if it exists\n        if (manager.search) {\n            await manager.search.start();\n        }\n\n        // Start interactions (mentions, replies)\n        await manager.interaction.start();\n\n        // If Spaces are enabled, start the periodic check\n        if (manager.space) {\n            manager.space.startPeriodicSpaceCheck();\n        }\n\n        return manager;\n    },\n};\n","import {\n    type Content,\n    type IAgentRuntime,\n    type IImageDescriptionService,\n    type Memory,\n    type State,\n    type UUID,\n    getEmbeddingZeroVector,\n    elizaLogger,\n    stringToUuid,\n    ActionTimelineType,\n} from \"@elizaos/core\";\nimport {\n    type QueryTweetsResponse,\n    Scraper,\n    SearchMode,\n    type Tweet,\n} from \"agent-twitter-client\";\nimport { EventEmitter } from \"events\";\nimport type { TwitterConfig } from \"./environment.ts\";\nimport {getTokensForUser} from \"./redisHelper.ts\";\n\nexport function extractAnswer(text: string): string {\n    const startIndex = text.indexOf(\"Answer: \") + 8;\n    const endIndex = text.indexOf(\"<|endoftext|>\", 11);\n    return text.slice(startIndex, endIndex);\n}\n\ntype TwitterProfile = {\n    id: string;\n    username: string;\n    screenName: string;\n    bio: string;\n    nicknames: string[];\n};\n\nclass RequestQueue {\n    private queue: (() => Promise<any>)[] = [];\n    private processing = false;\n\n    async add<T>(request: () => Promise<T>): Promise<T> {\n        return new Promise((resolve, reject) => {\n            this.queue.push(async () => {\n                try {\n                    const result = await request();\n                    resolve(result);\n                } catch (error) {\n                    reject(error);\n                }\n            });\n            this.processQueue();\n        });\n    }\n\n    private async processQueue(): Promise<void> {\n        if (this.processing || this.queue.length === 0) {\n            return;\n        }\n        this.processing = true;\n\n        while (this.queue.length > 0) {\n            const request = this.queue.shift()!;\n            try {\n                await request();\n            } catch (error) {\n                console.error(\"Error processing request:\", error);\n                this.queue.unshift(request);\n                await this.exponentialBackoff(this.queue.length);\n            }\n            await this.randomDelay();\n        }\n\n        this.processing = false;\n    }\n\n    private async exponentialBackoff(retryCount: number): Promise<void> {\n        const delay = Math.pow(2, retryCount) * 1000;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n\n    private async randomDelay(): Promise<void> {\n        const delay = Math.floor(Math.random() * 2000) + 1500;\n        await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n}\n\nexport class ClientBase extends EventEmitter {\n    static _twitterClients: { [accountIdentifier: string]: Scraper } = {};\n    twitterClient: Scraper;\n    runtime: IAgentRuntime;\n    twitterConfig: TwitterConfig;\n    directions: string;\n    lastCheckedTweetId: bigint | null = null;\n    imageDescriptionService: IImageDescriptionService;\n    temperature = 0.5;\n\n    requestQueue: RequestQueue = new RequestQueue();\n\n    profile: TwitterProfile | null;\n\n    async cacheTweet(tweet: Tweet): Promise<void> {\n        if (!tweet) {\n            console.warn(\"Tweet is undefined, skipping cache\");\n            return;\n        }\n\n        this.runtime.cacheManager.set(`twitter/tweets/${tweet.id}`, tweet);\n    }\n\n    async getCachedTweet(tweetId: string): Promise<Tweet | undefined> {\n        const cached = await this.runtime.cacheManager.get<Tweet>(\n            `twitter/tweets/${tweetId}`\n        );\n\n        return cached;\n    }\n\n    async getTweet(tweetId: string): Promise<Tweet> {\n        const cachedTweet = await this.getCachedTweet(tweetId);\n\n        if (cachedTweet) {\n            return cachedTweet;\n        }\n\n        const tweet = await this.requestQueue.add(() =>\n            this.twitterClient.getTweet(tweetId)\n        );\n\n        await this.cacheTweet(tweet);\n        return tweet;\n    }\n\n    callback: (self: ClientBase) => any = null;\n\n    onReady() {\n        throw new Error(\n            \"Not implemented in base class, please call from subclass\"\n        );\n    }\n\n    /**\n     * Parse the raw tweet data into a standardized Tweet object.\n     */\n    private parseTweet(raw: any, depth = 0, maxDepth = 3): Tweet {\n        // If we've reached maxDepth, don't parse nested quotes/retweets further\n        const canRecurse = depth < maxDepth;\n\n        const quotedStatus = raw.quoted_status_result?.result && canRecurse\n            ? this.parseTweet(raw.quoted_status_result.result, depth + 1, maxDepth)\n            : undefined;\n\n        const retweetedStatus = raw.retweeted_status_result?.result && canRecurse\n            ? this.parseTweet(raw.retweeted_status_result.result, depth + 1, maxDepth)\n            : undefined;\n\n        const t: Tweet = {\n            bookmarkCount:\n                raw.bookmarkCount ?? raw.legacy?.bookmark_count ?? undefined,\n            conversationId:\n                raw.conversationId ?? raw.legacy?.conversation_id_str,\n            hashtags: raw.hashtags ?? raw.legacy?.entities?.hashtags ?? [],\n            html: raw.html,\n            id: raw.id ?? raw.rest_id ?? raw.id_str ?? undefined,\n            inReplyToStatus: raw.inReplyToStatus,\n            inReplyToStatusId:\n                raw.inReplyToStatusId ??\n                raw.legacy?.in_reply_to_status_id_str ??\n                undefined,\n            isQuoted: raw.legacy?.is_quote_status === true,\n            isPin: raw.isPin,\n            isReply: raw.isReply,\n            isRetweet: raw.legacy?.retweeted === true,\n            isSelfThread: raw.isSelfThread,\n            language: raw.legacy?.lang,\n            likes: raw.legacy?.favorite_count ?? 0,\n            name:\n                raw.name ??\n                raw?.user_results?.result?.legacy?.name ??\n                raw.core?.user_results?.result?.legacy?.name,\n            mentions: raw.mentions ?? raw.legacy?.entities?.user_mentions ?? [],\n            permanentUrl:\n                raw.permanentUrl ??\n                (raw.core?.user_results?.result?.legacy?.screen_name &&\n                 raw.rest_id\n                    ? `https://x.com/${raw.core?.user_results?.result?.legacy?.screen_name}/status/${raw.rest_id}`\n                    : undefined),\n            photos:\n                raw.photos ??\n                (raw.legacy?.entities?.media\n                    ?.filter((media: any) => media.type === \"photo\")\n                    .map((media: any) => ({\n                        id: media.id_str,\n                        url: media.media_url_https,\n                        alt_text: media.alt_text,\n                    })) || []),\n            place: raw.place,\n            poll: raw.poll ?? null,\n            quotedStatus,\n            quotedStatusId:\n                raw.quotedStatusId ?? raw.legacy?.quoted_status_id_str ?? undefined,\n            quotes: raw.legacy?.quote_count ?? 0,\n            replies: raw.legacy?.reply_count ?? 0,\n            retweets: raw.legacy?.retweet_count ?? 0,\n            retweetedStatus,\n            retweetedStatusId: raw.legacy?.retweeted_status_id_str ?? undefined,\n            text: raw.text ?? raw.legacy?.full_text ?? undefined,\n            thread: raw.thread || [],\n            timeParsed: raw.timeParsed\n                ? new Date(raw.timeParsed)\n                : raw.legacy?.created_at\n                ? new Date(raw.legacy?.created_at)\n                : undefined,\n            timestamp:\n                raw.timestamp ??\n                (raw.legacy?.created_at\n                    ? new Date(raw.legacy.created_at).getTime() / 1000\n                    : undefined),\n            urls: raw.urls ?? raw.legacy?.entities?.urls ?? [],\n            userId: raw.userId ?? raw.legacy?.user_id_str ?? undefined,\n            username:\n                raw.username ??\n                raw.core?.user_results?.result?.legacy?.screen_name ??\n                undefined,\n            videos:\n                raw.videos ??\n                (raw.legacy?.entities?.media\n                    ?.filter((media: any) => media.type === \"video\") ?? []),\n            views: raw.views?.count ? Number(raw.views.count) : 0,\n            sensitiveContent: raw.sensitiveContent,\n        };\n\n        return t;\n    }\n\n    constructor(runtime: IAgentRuntime, twitterConfig: TwitterConfig) {\n        super();\n        this.runtime = runtime;\n        this.twitterConfig = twitterConfig;\n        const username = twitterConfig.TWITTER_USERNAME;\n        if (ClientBase._twitterClients[username]) {\n            this.twitterClient = ClientBase._twitterClients[username];\n        } else {\n            this.twitterClient = new Scraper();\n            ClientBase._twitterClients[username] = this.twitterClient;\n        }\n\n        this.directions =\n            \"- \" +\n            this.runtime.character.style.all.join(\"\\n- \") +\n            \"- \" +\n            this.runtime.character.style.post.join();\n    }\n\n    async init() {\n        const username = this.twitterConfig.TWITTER_USERNAME;\n        const password = this.twitterConfig.TWITTER_PASSWORD;\n        const email = this.twitterConfig.TWITTER_EMAIL;\n        let retries = this.twitterConfig.TWITTER_RETRY_LIMIT;\n        const twitter2faSecret = this.twitterConfig.TWITTER_2FA_SECRET;\n        const twitterApiKey = this.twitterConfig.TWITTER_API_KEY;\n        const twitterApiSecretKey = this.twitterConfig.TWITTER_API_SECRET_KEY;\n        const twitterAccessToken = this.twitterConfig.TWITTER_ACCESS_TOKEN;\n        const twitterAccessTokenSecret = this.twitterConfig.TWITTER_ACCESS_TOKEN_SECRET;\n\n        if (!username) {\n            throw new Error(\"Twitter username not configured\");\n        }\n\n        const authToken = this.runtime.getSetting(\"TWITTER_COOKIES_AUTH_TOKEN\");\n        const ct0 = this.runtime.getSetting(\"TWITTER_COOKIES_CT0\");\n        const guestId = this.runtime.getSetting(\"TWITTER_COOKIES_GUEST_ID\");\n\n        const createTwitterCookies = (authToken: string, ct0: string, guestId: string) =>\n        authToken && ct0 && guestId\n            ? [\n                { key: 'auth_token', value: authToken, domain: '.twitter.com' },\n                { key: 'ct0', value: ct0, domain: '.twitter.com' },\n                { key: 'guest_id', value: guestId, domain: '.twitter.com' },\n            ]\n            : null;\n\n        const cachedCookies = await this.getCachedCookies(username) || createTwitterCookies(authToken, ct0, guestId);\n\n        if (cachedCookies) {\n            elizaLogger.info(\"Using cached cookies\");\n            await this.setCookiesFromArray(cachedCookies);\n        }\n\n        elizaLogger.log(\"Waiting for Twitter login\");\n        while (retries > 0) {\n            try {\n                if (await this.twitterClient.isLoggedIn()) {\n                    // cookies are valid, no login required\n                    elizaLogger.info(\"Successfully logged in.\");\n                    break;\n                } else {\n                    await this.twitterClient.login(\n                        username,\n                        password,\n                        email,\n                        twitter2faSecret,\n                        twitterApiKey,\n                        twitterApiSecretKey,\n                        twitterAccessToken,\n                        twitterAccessTokenSecret\n                    );\n                    if (await this.twitterClient.isLoggedIn()) {\n                        // fresh login, store new cookies\n                        elizaLogger.info(\"Successfully logged in.\");\n                        elizaLogger.info(\"Caching cookies\");\n                        await this.cacheCookies(\n                            username,\n                            await this.twitterClient.getCookies()\n                        );\n                        break;\n                    }\n                }\n            } catch (error) {\n                elizaLogger.error(`Login attempt failed: ${error.message}`);\n            }\n\n            retries--;\n            elizaLogger.error(\n                `Failed to login to Twitter. Retrying... (${retries} attempts left)`\n            );\n\n            if (retries === 0) {\n                elizaLogger.error(\n                    \"Max retries reached. Exiting login process.\"\n                );\n                throw new Error(\"Twitter login failed after maximum retries.\");\n            }\n\n            await new Promise((resolve) => setTimeout(resolve, 2000));\n        }\n        // Initialize Twitter profile\n        this.profile = await this.fetchProfile(username);\n\n        if (this.profile) {\n            elizaLogger.log(\"Twitter user ID:\", this.profile.id);\n            elizaLogger.log(\n                \"Twitter loaded:\",\n                JSON.stringify(this.profile, null, 10)\n            );\n            // Store profile info for use in responses\n            this.runtime.character.twitterProfile = {\n                id: this.profile.id,\n                username: this.profile.username,\n                screenName: this.profile.screenName,\n                bio: this.profile.bio,\n                nicknames: this.profile.nicknames,\n            };\n        } else {\n            throw new Error(\"Failed to load profile\");\n        }\n\n        await this.loadLatestCheckedTweetId();\n        await this.populateTimeline();\n    }\n\n    async fetchOwnPosts(count: number): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching own posts\");\n        const homeTimeline = await this.twitterClient.getUserTweets(\n            this.profile.id,\n            count\n        );\n        // Use parseTweet on each tweet\n        return homeTimeline.tweets.map((t) => this.parseTweet(t));\n    }\n\n    /**\n     * Fetch timeline for twitter account, optionally only from followed accounts\n     */\n    async fetchHomeTimeline(\n        count: number,\n        following?: boolean\n    ): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching home timeline\");\n        const homeTimeline = following\n            ? await this.twitterClient.fetchFollowingTimeline(count, [])\n            : await this.twitterClient.fetchHomeTimeline(count, []);\n\n        elizaLogger.debug(homeTimeline, { depth: Number.POSITIVE_INFINITY });\n        const processedTimeline = homeTimeline\n            .filter((t) => t.__typename !== \"TweetWithVisibilityResults\") // what's this about?\n            .map((tweet) => this.parseTweet(tweet));\n\n        //elizaLogger.debug(\"process homeTimeline\", processedTimeline);\n        return processedTimeline;\n    }\n\n    async fetchTimelineForActions(count: number): Promise<Tweet[]> {\n        elizaLogger.debug(\"fetching timeline for actions\");\n\n        const agentUsername = this.twitterConfig.TWITTER_USERNAME;\n\n        const homeTimeline =\n            this.twitterConfig.ACTION_TIMELINE_TYPE ===\n            ActionTimelineType.Following\n                ? await this.twitterClient.fetchFollowingTimeline(count, [])\n                : await this.twitterClient.fetchHomeTimeline(count, []);\n\n        // Parse, filter out self-tweets, limit to count\n        return homeTimeline\n            .map((tweet) => this.parseTweet(tweet))\n            .filter((tweet) => tweet.username !== agentUsername) // do not perform action on self-tweets\n            .slice(0, count);\n        // TODO: Once the 'count' parameter is fixed in the 'fetchTimeline' method of the 'agent-twitter-client',\n        // this workaround can be removed.\n        // Related issue: https://github.com/elizaos/agent-twitter-client/issues/43\n    }\n\n    async fetchSearchTweets(\n        query: string,\n        maxTweets: number,\n        searchMode: SearchMode,\n        cursor?: string\n    ): Promise<QueryTweetsResponse> {\n        try {\n            // Sometimes this fails because we are rate limited. in this case, we just need to return an empty array\n            // if we dont get a response in 5 seconds, something is wrong\n            const timeoutPromise = new Promise((resolve) =>\n                setTimeout(() => resolve({ tweets: [] }), 15000)\n            );\n\n            try {\n                const result = await this.requestQueue.add(\n                    async () =>\n                        await Promise.race([\n                            this.twitterClient.fetchSearchTweets(\n                                query,\n                                maxTweets,\n                                searchMode,\n                                cursor\n                            ),\n                            timeoutPromise,\n                        ])\n                );\n                return (result ?? { tweets: [] }) as QueryTweetsResponse;\n            } catch (error) {\n                elizaLogger.error(\"Error fetching search tweets:\", error);\n                return { tweets: [] };\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error fetching search tweets:\", error);\n            return { tweets: [] };\n        }\n    }\n\n    private async populateTimeline() {\n        elizaLogger.debug(\"populating timeline...\");\n\n        const cachedTimeline = await this.getCachedTimeline();\n\n        // Check if the cache file exists\n        if (cachedTimeline) {\n            // Read the cached search results from the file\n\n            // Get the existing memories from the database\n            const existingMemories =\n                await this.runtime.messageManager.getMemoriesByRoomIds({\n                    roomIds: cachedTimeline.map((tweet) =>\n                        stringToUuid(\n                            tweet.conversationId + \"-\" + this.runtime.agentId\n                        )\n                    ),\n                });\n\n            //TODO: load tweets not in cache?\n\n            // Create a Set to store the IDs of existing memories\n            const existingMemoryIds = new Set(\n                existingMemories.map((memory) => memory.id.toString())\n            );\n\n            // Check if any of the cached tweets exist in the existing memories\n            const someCachedTweetsExist = cachedTimeline.some((tweet) =>\n                existingMemoryIds.has(\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                )\n            );\n\n            if (someCachedTweetsExist) {\n                // Filter out the cached tweets that already exist in the database\n                const tweetsToSave = cachedTimeline.filter(\n                    (tweet) =>\n                        !existingMemoryIds.has(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        )\n                );\n\n                console.log({\n                    processingTweets: tweetsToSave\n                        .map((tweet) => tweet.id)\n                        .join(\",\"),\n                });\n\n                // Save the missing tweets as memories\n                for (const tweet of tweetsToSave) {\n                    elizaLogger.log(\"Saving Tweet\", tweet.id);\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const userId =\n                        tweet.userId === this.profile.id\n                            ? this.runtime.agentId\n                            : stringToUuid(tweet.userId);\n\n                    if (tweet.userId === this.profile.id) {\n                        await this.runtime.ensureConnection(\n                            this.runtime.agentId,\n                            roomId,\n                            this.profile.username,\n                            this.profile.screenName,\n                            \"twitter\"\n                        );\n                    } else {\n                        await this.runtime.ensureConnection(\n                            userId,\n                            roomId,\n                            tweet.username,\n                            tweet.name,\n                            \"twitter\"\n                        );\n                    }\n\n                    const content = {\n                        text: tweet.text,\n                        url: tweet.permanentUrl,\n                        source: \"twitter\",\n                        inReplyTo: tweet.inReplyToStatusId\n                            ? stringToUuid(\n                                  tweet.inReplyToStatusId +\n                                      \"-\" +\n                                      this.runtime.agentId\n                              )\n                            : undefined,\n                    } as Content;\n\n                    elizaLogger.log(\"Creating memory for tweet\", tweet.id);\n\n                    // check if it already exists\n                    const memory =\n                        await this.runtime.messageManager.getMemoryById(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        );\n\n                    if (memory) {\n                        elizaLogger.log(\n                            \"Memory already exists, skipping timeline population\"\n                        );\n                        break;\n                    }\n\n                    await this.runtime.messageManager.createMemory({\n                        id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                        userId,\n                        content: content,\n                        agentId: this.runtime.agentId,\n                        roomId,\n                        embedding: getEmbeddingZeroVector(),\n                        createdAt: tweet.timestamp * 1000,\n                    });\n\n                    await this.cacheTweet(tweet);\n                }\n\n                elizaLogger.log(\n                    `Populated ${tweetsToSave.length} missing tweets from the cache.`\n                );\n                return;\n            }\n        }\n\n        const timeline = await this.fetchHomeTimeline(cachedTimeline ? 10 : 50);\n        const username = this.twitterConfig.TWITTER_USERNAME;\n\n        // Get the most recent 20 mentions and interactions\n        const mentionsAndInteractions = await this.fetchSearchTweets(\n            `@${username}`,\n            20,\n            SearchMode.Latest\n        );\n\n        // Combine the timeline tweets and mentions/interactions\n        const allTweets = [...timeline, ...mentionsAndInteractions.tweets];\n\n        // Create a Set to store unique tweet IDs\n        const tweetIdsToCheck = new Set<string>();\n        const roomIds = new Set<UUID>();\n\n        // Add tweet IDs to the Set\n        for (const tweet of allTweets) {\n            tweetIdsToCheck.add(tweet.id);\n            roomIds.add(\n                stringToUuid(tweet.conversationId + \"-\" + this.runtime.agentId)\n            );\n        }\n\n        // Check the existing memories in the database\n        const existingMemories =\n            await this.runtime.messageManager.getMemoriesByRoomIds({\n                roomIds: Array.from(roomIds),\n            });\n\n        // Create a Set to store the existing memory IDs\n        const existingMemoryIds = new Set<UUID>(\n            existingMemories.map((memory) => memory.id)\n        );\n\n        // Filter out the tweets that already exist in the database\n        const tweetsToSave = allTweets.filter(\n            (tweet) =>\n                !existingMemoryIds.has(\n                    stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                )\n        );\n\n        elizaLogger.debug({\n            processingTweets: tweetsToSave.map((tweet) => tweet.id).join(\",\"),\n        });\n\n        await this.runtime.ensureUserExists(\n            this.runtime.agentId,\n            this.profile.username,\n            this.runtime.character.name,\n            \"twitter\"\n        );\n\n        // Save the new tweets as memories\n        for (const tweet of tweetsToSave) {\n            elizaLogger.log(\"Saving Tweet\", tweet.id);\n\n            const roomId = stringToUuid(\n                tweet.conversationId + \"-\" + this.runtime.agentId\n            );\n            const userId =\n                tweet.userId === this.profile.id\n                    ? this.runtime.agentId\n                    : stringToUuid(tweet.userId);\n\n            if (tweet.userId === this.profile.id) {\n                await this.runtime.ensureConnection(\n                    this.runtime.agentId,\n                    roomId,\n                    this.profile.username,\n                    this.profile.screenName,\n                    \"twitter\"\n                );\n            } else {\n                await this.runtime.ensureConnection(\n                    userId,\n                    roomId,\n                    tweet.username,\n                    tweet.name,\n                    \"twitter\"\n                );\n            }\n\n            const content = {\n                text: tweet.text,\n                url: tweet.permanentUrl,\n                source: \"twitter\",\n                inReplyTo: tweet.inReplyToStatusId\n                    ? stringToUuid(tweet.inReplyToStatusId)\n                    : undefined,\n            } as Content;\n\n            await this.runtime.messageManager.createMemory({\n                id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                userId,\n                content: content,\n                agentId: this.runtime.agentId,\n                roomId,\n                embedding: getEmbeddingZeroVector(),\n                createdAt: tweet.timestamp * 1000,\n            });\n\n            await this.cacheTweet(tweet);\n        }\n\n        // Cache\n        await this.cacheTimeline(timeline);\n        await this.cacheMentions(mentionsAndInteractions.tweets);\n    }\n\n    async setCookiesFromArray(cookiesArray: any[]) {\n        const cookieStrings = cookiesArray.map(\n            (cookie) =>\n                `${cookie.key}=${cookie.value}; Domain=${cookie.domain}; Path=${cookie.path}; ${\n                    cookie.secure ? \"Secure\" : \"\"\n                }; ${cookie.httpOnly ? \"HttpOnly\" : \"\"}; SameSite=${\n                    cookie.sameSite || \"Lax\"\n                }`\n        );\n        await this.twitterClient.setCookies(cookieStrings);\n    }\n\n    async saveRequestMessage(message: Memory, state: State) {\n        if (message.content.text) {\n            const recentMessage = await this.runtime.messageManager.getMemories(\n                {\n                    roomId: message.roomId,\n                    count: 1,\n                    unique: false,\n                }\n            );\n\n            if (\n                recentMessage.length > 0 &&\n                recentMessage[0].content === message.content\n            ) {\n                elizaLogger.debug(\"Message already saved\", recentMessage[0].id);\n            } else {\n                await this.runtime.messageManager.createMemory({\n                    ...message,\n                    embedding: getEmbeddingZeroVector(),\n                });\n            }\n\n            await this.runtime.evaluate(message, {\n                ...state,\n                twitterClient: this.twitterClient,\n            });\n        }\n    }\n\n    async loadLatestCheckedTweetId(): Promise<void> {\n        const latestCheckedTweetId =\n            await this.runtime.cacheManager.get<string>(\n                `twitter/${this.profile.username}/latest_checked_tweet_id`\n            );\n\n        if (latestCheckedTweetId) {\n            this.lastCheckedTweetId = BigInt(latestCheckedTweetId);\n        }\n    }\n\n    async cacheLatestCheckedTweetId() {\n        if (this.lastCheckedTweetId) {\n            await this.runtime.cacheManager.set(\n                `twitter/${this.profile.username}/latest_checked_tweet_id`,\n                this.lastCheckedTweetId.toString()\n            );\n        }\n    }\n\n    async getCachedTimeline(): Promise<Tweet[] | undefined> {\n        return await this.runtime.cacheManager.get<Tweet[]>(\n            `twitter/${this.profile.username}/timeline`\n        );\n    }\n\n    async cacheTimeline(timeline: Tweet[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${this.profile.username}/timeline`,\n            timeline,\n            { expires: Date.now() + 10 * 1000 }\n        );\n    }\n\n    async cacheMentions(mentions: Tweet[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${this.profile.username}/mentions`,\n            mentions,\n            { expires: Date.now() + 10 * 1000 }\n        );\n    }\n\n    async getCachedCookies(username: string) {\n        return await this.runtime.cacheManager.get<any[]>(\n            `twitter/${username}/cookies`\n        );\n    }\n\n    async cacheCookies(username: string, cookies: any[]) {\n        await this.runtime.cacheManager.set(\n            `twitter/${username}/cookies`,\n            cookies\n        );\n    }\n\n    async fetchProfile(username: string): Promise<TwitterProfile> {\n        try {\n            const profile = await this.requestQueue.add(async () => {\n                const profile = await this.twitterClient.getProfile(username);\n                return {\n                    id: profile.userId,\n                    username,\n                    screenName: profile.name || this.runtime.character.name,\n                    bio:\n                        profile.biography ||\n                        typeof this.runtime.character.bio === \"string\"\n                            ? (this.runtime.character.bio as string)\n                            : this.runtime.character.bio.length > 0\n                              ? this.runtime.character.bio[0]\n                              : \"\",\n                    nicknames:\n                        this.runtime.character.twitterProfile?.nicknames || [],\n                } satisfies TwitterProfile;\n            });\n\n            return profile;\n        } catch (error) {\n            console.error(\"Error fetching Twitter profile:\", error);\n            throw error;\n        }\n    }\n}\n","import {ActionTimelineType, type IAgentRuntime, parseBooleanFromText,} from \"@elizaos/core\";\nimport {z, ZodError} from \"zod\";\n\nexport const DEFAULT_MAX_TWEET_LENGTH = 280;\n\nconst twitterUsernameSchema = z\n    .string()\n    .min(1, \"An X/Twitter Username must be at least 1 character long\")\n    .max(15, \"An X/Twitter Username cannot exceed 15 characters\")\n    .refine((username) => {\n        // Allow wildcard '*' as a special case\n        if (username === \"*\") return true;\n\n        // Twitter usernames can:\n        // - Start with digits now\n        // - Contain letters, numbers, underscores\n        // - Must not be empty\n        return /^[A-Za-z0-9_]+$/.test(username);\n    }, \"An X Username can only contain letters, numbers, and underscores\");\n\n/**\n * This schema defines all required/optional environment settings,\n * including new fields like TWITTER_SPACES_ENABLE.\n */\nexport const twitterEnvSchema = z.object({\n    TWITTER_DRY_RUN: z.boolean(),\n    TWITTER_USERNAME: z.string().min(1, \"X/Twitter username is required\"),\n    TWITTER_PASSWORD: z.string().default(\"something\"),\n    TWITTER_API_KEY: z.string().min(1, \"X V2 Credentials required\"),\n    TWITTER_API_SECRET_KEY: z.string().min(1, \"X V2 Credentials required\"),\n    TWITTER_ACCESS_TOKEN: z.string().min(1, \"X V2 Credentials required\"),\n    TWITTER_ACCESS_TOKEN_SECRET: z.string().min(1, \"X V2 Credentials required\"),\n\n    TWITTER_EMAIL: z.string().default(\"something\"),\n    MAX_TWEET_LENGTH: z.number().int().default(DEFAULT_MAX_TWEET_LENGTH),\n    TWITTER_SEARCH_ENABLE: z.boolean().default(false),\n    TWITTER_2FA_SECRET: z.string(),\n    TWITTER_RETRY_LIMIT: z.number().int(),\n    TWITTER_POLL_INTERVAL: z.number().int(),\n    TWITTER_TARGET_USERS: z.array(twitterUsernameSchema).default([]),\n    ENABLE_TWITTER_POST_GENERATION: z.boolean(),\n    POST_INTERVAL_MIN: z.number().int(),\n    POST_INTERVAL_MAX: z.number().int(),\n    ENABLE_ACTION_PROCESSING: z.boolean(),\n    ACTION_INTERVAL: z.number().int(),\n    POST_IMMEDIATELY: z.boolean(),\n    TWITTER_SPACES_ENABLE: z.boolean().default(false),\n    MAX_ACTIONS_PROCESSING: z.number().int(),\n    ACTION_TIMELINE_TYPE: z\n        .nativeEnum(ActionTimelineType)\n        .default(ActionTimelineType.ForYou),\n});\n\nexport type TwitterConfig = z.infer<typeof twitterEnvSchema>;\n\n/**\n * Helper to parse a comma-separated list of Twitter usernames\n * (already present in your code).\n */\nfunction parseTargetUsers(targetUsersStr?: string | null): string[] {\n    if (!targetUsersStr?.trim()) {\n        return [];\n    }\n    return targetUsersStr\n        .split(\",\")\n        .map((user) => user.trim())\n        .filter(Boolean);\n}\n\nfunction safeParseInt(\n    value: string | undefined | null,\n    defaultValue: number\n): number {\n    if (!value) return defaultValue;\n    const parsed = Number.parseInt(value, 10);\n    return isNaN(parsed) ? defaultValue : Math.max(1, parsed);\n}\n\n/**\n * Validates or constructs a TwitterConfig object using zod,\n * taking values from the IAgentRuntime or process.env as needed.\n */\n// This also is organized to serve as a point of documentation for the client\n// most of the inputs from the framework (env/character)\n\n// we also do a lot of typing/parsing here\n// so we can do it once and only once per character\nexport async function validateTwitterConfig(\n    runtime: IAgentRuntime\n): Promise<TwitterConfig> {\n    try {\n        const twitterConfig = {\n            TWITTER_DRY_RUN:\n                parseBooleanFromText(\n                    runtime.getSetting(\"TWITTER_DRY_RUN\") ||\n                    process.env.TWITTER_DRY_RUN\n                ) ?? false, // parseBooleanFromText return null if \"\", map \"\" to false\n\n            TWITTER_USERNAME:\n                runtime.getSetting(\"TWITTER_USERNAME\") ||\n                process.env.TWITTER_USERNAME,\n\n            TWITTER_API_KEY: runtime.getSetting(\"TWITTER_API_KEY\") ||\n                process.env.TWITTER_API_KEY,\n            TWITTER_API_SECRET_KEY: runtime.getSetting(\"TWITTER_API_SECRET_KEY\") || process.env.TWITTER_API_SECRET_KEY,\n            TWITTER_ACCESS_TOKEN: runtime.getSetting(\"TWITTER_ACCESS_TOKEN\") || process.env.TWITTER_ACCESS_TOKEN,\n            TWITTER_ACCESS_TOKEN_SECRET: runtime.getSetting(\"TWITTER_ACCESS_TOKEN_SECRET\") || process.env.TWITTER_ACCESS_TOKEN_SECRET,\n\n            TWITTER_PASSWORD:\n                runtime.getSetting(\"TWITTER_PASSWORD\") ||\n                process.env.TWITTER_PASSWORD,\n\n            TWITTER_EMAIL:\n                runtime.getSetting(\"TWITTER_EMAIL\") ||\n                process.env.TWITTER_EMAIL,\n\n            // number as string?\n            MAX_TWEET_LENGTH: safeParseInt(\n                runtime.getSetting(\"MAX_TWEET_LENGTH\") ||\n                process.env.MAX_TWEET_LENGTH,\n                DEFAULT_MAX_TWEET_LENGTH\n            ),\n\n            TWITTER_SEARCH_ENABLE:\n                parseBooleanFromText(\n                    runtime.getSetting(\"TWITTER_SEARCH_ENABLE\") ||\n                    process.env.TWITTER_SEARCH_ENABLE\n                ) ?? false,\n\n            // string passthru\n            TWITTER_2FA_SECRET:\n                runtime.getSetting(\"TWITTER_2FA_SECRET\") ||\n                process.env.TWITTER_2FA_SECRET ||\n                \"\",\n\n            // int\n            TWITTER_RETRY_LIMIT: safeParseInt(\n                runtime.getSetting(\"TWITTER_RETRY_LIMIT\") ||\n                process.env.TWITTER_RETRY_LIMIT,\n                5\n            ),\n\n            // int in seconds\n            TWITTER_POLL_INTERVAL: safeParseInt(\n                runtime.getSetting(\"TWITTER_POLL_INTERVAL\") ||\n                process.env.TWITTER_POLL_INTERVAL,\n                120 // 2m\n            ),\n\n            // comma separated string\n            TWITTER_TARGET_USERS: parseTargetUsers(\n                runtime.getSetting(\"TWITTER_TARGET_USERS\") ||\n                process.env.TWITTER_TARGET_USERS\n            ),\n\n            // bool\n            ENABLE_TWITTER_POST_GENERATION:\n                parseBooleanFromText(\n                    runtime.getSetting(\"ENABLE_TWITTER_POST_GENERATION\") ||\n                    process.env.ENABLE_TWITTER_POST_GENERATION\n                ) ?? true,\n\n\n            // int in minutes\n            POST_INTERVAL_MIN: safeParseInt(\n                runtime.getSetting(\"POST_INTERVAL_MIN\") ||\n                process.env.POST_INTERVAL_MIN,\n                90 // 1.5 hours\n            ),\n\n            // int in minutes\n            POST_INTERVAL_MAX: safeParseInt(\n                runtime.getSetting(\"POST_INTERVAL_MAX\") ||\n                process.env.POST_INTERVAL_MAX,\n                180 // 3 hours\n            ),\n\n            // bool\n            ENABLE_ACTION_PROCESSING:\n                parseBooleanFromText(\n                    runtime.getSetting(\"ENABLE_ACTION_PROCESSING\") ||\n                    process.env.ENABLE_ACTION_PROCESSING\n                ) ?? false,\n\n            // init in minutes (min 1m)\n            ACTION_INTERVAL: safeParseInt(\n                runtime.getSetting(\"ACTION_INTERVAL\") ||\n                process.env.ACTION_INTERVAL,\n                5 // 5 minutes\n            ),\n\n            // bool\n            POST_IMMEDIATELY:\n                parseBooleanFromText(\n                    runtime.getSetting(\"POST_IMMEDIATELY\") ||\n                    process.env.POST_IMMEDIATELY\n                ) ?? false,\n\n            TWITTER_SPACES_ENABLE:\n                parseBooleanFromText(\n                    runtime.getSetting(\"TWITTER_SPACES_ENABLE\") ||\n                    process.env.TWITTER_SPACES_ENABLE\n                ) ?? false,\n\n            MAX_ACTIONS_PROCESSING: safeParseInt(\n                runtime.getSetting(\"MAX_ACTIONS_PROCESSING\") ||\n                process.env.MAX_ACTIONS_PROCESSING,\n                1\n            ),\n\n            ACTION_TIMELINE_TYPE:\n                runtime.getSetting(\"ACTION_TIMELINE_TYPE\") ||\n                process.env.ACTION_TIMELINE_TYPE,\n        };\n\n        return twitterEnvSchema.parse(twitterConfig);\n    } catch (error) {\n        if (error instanceof ZodError) {\n            const errorMessages = error.errors\n                .map((err) => `${err.path.join(\".\")}: ${err.message}`)\n                .join(\"\\n\");\n            throw new Error(\n                `X/Twitter configuration validation failed:\\n${errorMessages}`\n            );\n        }\n        throw error;\n    }\n}\n","import { SearchMode, type Tweet } from \"agent-twitter-client\";\nimport {\n    composeContext,\n    generateMessageResponse,\n    generateShouldRespond,\n    messageCompletionFooter,\n    shouldRespondFooter,\n    type Content,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n    stringToUuid,\n    elizaLogger,\n    getEmbeddingZeroVector,\n    type IImageDescriptionService,\n    ServiceType\n} from \"@elizaos/core\";\nimport type { ClientBase } from \"./base\";\nimport { buildConversationThread, sendTweet, wait } from \"./utils.ts\";\n\nexport const twitterMessageHandlerTemplate =\n    `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\n{{recentPosts}}\n\n# TASK: Generate a post/reply in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}) while using the thread of tweets as additional context:\n\nCurrent Post:\n{{currentPost}}\nHere is the descriptions of images in the Current post.\n{{imageDescriptions}}\n\nThread of Tweets You Are Replying To:\n{{formattedConversation}}\n\n# INSTRUCTIONS: Generate a post in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}). You MUST include an action if the current post text includes a prompt that is similar to one of the available actions mentioned here:\n{{actionNames}}\n{{actions}}\n\nGenerate a meme to go along with the post, featuring character: {{agentName}}, decide between meme and no meme randoamlly.\n\nHere is the current post text again. Remember to include an action if the current post text includes a prompt that asks for one of the available actions mentioned above (does not need to be exact)\n{{currentPost}}\nHere is the descriptions of images in the Current post.\n{{imageDescriptions}}\n` + messageCompletionFooter;\n\nexport const twitterShouldRespondTemplate = (targetUsersStr: string) =>\n    `# INSTRUCTIONS: Determine if {{agentName}} (@{{twitterUserName}}) should respond to the message and participate in the conversation. Do not comment. Just respond with \"true\" or \"false\".\n\nResponse options are RESPOND, IGNORE and STOP.\n\nPRIORITY RULE: ALWAYS RESPOND to these users regardless of topic or message content: ${targetUsersStr}. Topic relevance should be ignored for these users.\n\nFor other users:\n- {{agentName}} should RESPOND to messages directed at them\n- {{agentName}} should RESPOND to conversations relevant to their background\n- {{agentName}} should IGNORE irrelevant messages\n- {{agentName}} should IGNORE very short messages unless directly addressed\n- {{agentName}} should STOP if asked to stop\n- {{agentName}} should STOP if conversation is concluded\n- {{agentName}} is in a room with other users and wants to be conversational, but not annoying.\n\nIMPORTANT:\n- {{agentName}} (aka @{{twitterUserName}}) is particularly sensitive about being annoying, so if there is any doubt, it is better to IGNORE than to RESPOND.\n- For users not in the priority list, {{agentName}} (@{{twitterUserName}}) should err on the side of IGNORE rather than RESPOND if in doubt.\n\nRecent Posts:\n{{recentPosts}}\n\nCurrent Post:\n{{currentPost}}\n\nThread of Tweets You Are Replying To:\n{{formattedConversation}}\n\n# INSTRUCTIONS: Respond with [RESPOND] if {{agentName}} should respond, or [IGNORE] if {{agentName}} should not respond to the last message and [STOP] if {{agentName}} should stop participating in the conversation.\n` + shouldRespondFooter;\n\nexport class TwitterInteractionClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    private isDryRun: boolean;\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n        this.isDryRun = this.client.twitterConfig.TWITTER_DRY_RUN;\n    }\n\n    async start() {\n        const handleTwitterInteractionsLoop = () => {\n            this.handleTwitterInteractions();\n            setTimeout(\n                handleTwitterInteractionsLoop,\n                // Defaults to 2 minutes\n                this.client.twitterConfig.TWITTER_POLL_INTERVAL * 1000\n            );\n        };\n        handleTwitterInteractionsLoop();\n    }\n\n    async handleTwitterInteractions() {\n        elizaLogger.log(\"Checking Twitter interactions\");\n\n        const twitterUsername = this.client.profile.username;\n        try {\n            // Check for mentions\n            const mentionCandidates = (\n                await this.client.fetchSearchTweets(\n                    `@${twitterUsername}`,\n                    20,\n                    SearchMode.Latest\n                )\n            ).tweets;\n\n            elizaLogger.log(\n                \"Completed checking mentioned tweets:\",\n                mentionCandidates.length\n            );\n            let uniqueTweetCandidates = [...mentionCandidates];\n            // Only process target users if configured\n            if (this.client.twitterConfig.TWITTER_TARGET_USERS.length) {\n                const TARGET_USERS =\n                    this.client.twitterConfig.TWITTER_TARGET_USERS;\n\n                elizaLogger.log(\"Processing target users:\", TARGET_USERS);\n\n                if (TARGET_USERS.length > 0) {\n                    // Create a map to store tweets by user\n                    const tweetsByUser = new Map<string, Tweet[]>();\n\n                    // Fetch tweets from all target users\n                    for (const username of TARGET_USERS) {\n                        try {\n                            const userTweets = (\n                                await this.client.twitterClient.fetchSearchTweets(\n                                    `from:${username}`,\n                                    3,\n                                    SearchMode.Latest\n                                )\n                            ).tweets;\n\n                            // Filter for unprocessed, non-reply, recent tweets\n                            const validTweets = userTweets.filter((tweet) => {\n                                const isUnprocessed =\n                                    !this.client.lastCheckedTweetId ||\n                                    Number.parseInt(tweet.id) >\n                                        this.client.lastCheckedTweetId;\n                                const isRecent =\n                                    Date.now() - tweet.timestamp * 1000 <\n                                    2 * 60 * 60 * 1000;\n\n                                elizaLogger.log(`Tweet ${tweet.id} checks:`, {\n                                    isUnprocessed,\n                                    isRecent,\n                                    isReply: tweet.isReply,\n                                    isRetweet: tweet.isRetweet,\n                                });\n\n                                return (\n                                    isUnprocessed &&\n                                    !tweet.isReply &&\n                                    !tweet.isRetweet &&\n                                    isRecent\n                                );\n                            });\n\n                            if (validTweets.length > 0) {\n                                tweetsByUser.set(username, validTweets);\n                                elizaLogger.log(\n                                    `Found ${validTweets.length} valid tweets from ${username}`\n                                );\n                            }\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error fetching tweets for ${username}:`,\n                                error\n                            );\n                            continue;\n                        }\n                    }\n\n                    // Select one tweet from each user that has tweets\n                    const selectedTweets: Tweet[] = [];\n                    for (const [username, tweets] of tweetsByUser) {\n                        if (tweets.length > 0) {\n                            // Randomly select one tweet from this user\n                            const randomTweet =\n                                tweets[\n                                    Math.floor(Math.random() * tweets.length)\n                                ];\n                            selectedTweets.push(randomTweet);\n                            elizaLogger.log(\n                                `Selected tweet from ${username}: ${randomTweet.text?.substring(0, 100)}`\n                            );\n                        }\n                    }\n\n                    // Add selected tweets to candidates\n                    uniqueTweetCandidates = [\n                        ...mentionCandidates,\n                        ...selectedTweets,\n                    ];\n                }\n            } else {\n                elizaLogger.log(\n                    \"No target users configured, processing only mentions\"\n                );\n            }\n\n            // Sort tweet candidates by ID in ascending order\n            uniqueTweetCandidates\n                .sort((a, b) => a.id.localeCompare(b.id))\n                .filter((tweet) => tweet.userId !== this.client.profile.id);\n\n            // for each tweet candidate, handle the tweet\n            for (const tweet of uniqueTweetCandidates) {\n                if (\n                    !this.client.lastCheckedTweetId ||\n                    BigInt(tweet.id) > this.client.lastCheckedTweetId\n                ) {\n                    // Generate the tweetId UUID the same way it's done in handleTweet\n                    const tweetId = stringToUuid(\n                        tweet.id + \"-\" + this.runtime.agentId\n                    );\n\n                    // Check if we've already processed this tweet\n                    const existingResponse =\n                        await this.runtime.messageManager.getMemoryById(\n                            tweetId\n                        );\n\n                    if (existingResponse) {\n                        elizaLogger.log(\n                            `Already responded to tweet ${tweet.id}, skipping`\n                        );\n                        continue;\n                    }\n                    elizaLogger.log(\"New Tweet found\", tweet.permanentUrl);\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const userIdUUID =\n                        tweet.userId === this.client.profile.id\n                            ? this.runtime.agentId\n                            : stringToUuid(tweet.userId!);\n\n                    await this.runtime.ensureConnection(\n                        userIdUUID,\n                        roomId,\n                        tweet.username,\n                        tweet.name,\n                        \"twitter\"\n                    );\n\n                    const thread = await buildConversationThread(\n                        tweet,\n                        this.client\n                    );\n\n                    const message = {\n                        content: { \n                            text: tweet.text,\n                            imageUrls: tweet.photos?.map(photo => photo.url) || []\n                        },\n                        agentId: this.runtime.agentId,\n                        userId: userIdUUID,\n                        roomId,\n                    };\n\n                    await this.handleTweet({\n                        tweet,\n                        message,\n                        thread,\n                    });\n\n                    // Update the last checked tweet ID after processing each tweet\n                    this.client.lastCheckedTweetId = BigInt(tweet.id);\n                }\n            }\n\n            // Save the latest checked tweet ID to the file\n            await this.client.cacheLatestCheckedTweetId();\n\n            elizaLogger.log(\"Finished checking Twitter interactions\");\n        } catch (error) {\n            elizaLogger.error(\"Error handling Twitter interactions:\", error);\n        }\n    }\n\n    private async handleTweet({\n        tweet,\n        message,\n        thread,\n    }: {\n        tweet: Tweet;\n        message: Memory;\n        thread: Tweet[];\n    }) {\n        // Only skip if tweet is from self AND not from a target user\n        if (tweet.userId === this.client.profile.id &&\n            !this.client.twitterConfig.TWITTER_TARGET_USERS.includes(tweet.username)) {\n            return;\n        }\n\n        if (!message.content.text) {\n            elizaLogger.log(\"Skipping Tweet with no text\", tweet.id);\n            return { text: \"\", action: \"IGNORE\" };\n        }\n\n        elizaLogger.log(\"Processing Tweet: \", tweet.id);\n        const formatTweet = (tweet: Tweet) => {\n            return `  ID: ${tweet.id}\n  From: ${tweet.name} (@${tweet.username})\n  Text: ${tweet.text}`;\n        };\n        const currentPost = formatTweet(tweet);\n\n        const formattedConversation = thread\n            .map(\n                (tweet) => `@${tweet.username} (${new Date(\n                    tweet.timestamp * 1000\n                ).toLocaleString(\"en-US\", {\n                    hour: \"2-digit\",\n                    minute: \"2-digit\",\n                    month: \"short\",\n                    day: \"numeric\",\n                })}):\n        ${tweet.text}`\n            )\n            .join(\"\\n\\n\");\n\n        const imageDescriptionsArray = [];\n        try{\n            for (const photo of tweet.photos) {\n                const description = await this.runtime\n                    .getService<IImageDescriptionService>(\n                        ServiceType.IMAGE_DESCRIPTION\n                    )\n                    .describeImage(photo.url);\n                imageDescriptionsArray.push(description);\n            }\n        } catch (error) {\n    // Handle the error\n    elizaLogger.error(\"Error Occured during describing image: \", error);\n}\n\n\n\n\n        let state = await this.runtime.composeState(message, {\n            twitterClient: this.client.twitterClient,\n            twitterUserName: this.client.twitterConfig.TWITTER_USERNAME,\n            currentPost,\n            formattedConversation,\n            imageDescriptions: imageDescriptionsArray.length > 0\n            ? `\\nImages in Tweet:\\n${imageDescriptionsArray.map((desc, i) =>\n              `Image ${i + 1}: Title: ${desc.title}\\nDescription: ${desc.description}`).join(\"\\n\\n\")}`:\"\"\n        });\n\n        // check if the tweet exists, save if it doesn't\n        const tweetId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\n        const tweetExists =\n            await this.runtime.messageManager.getMemoryById(tweetId);\n\n        if (!tweetExists) {\n            elizaLogger.log(\"tweet does not exist, saving\");\n            const userIdUUID = stringToUuid(tweet.userId as string);\n            const roomId = stringToUuid(tweet.conversationId);\n\n            const message = {\n                id: tweetId,\n                agentId: this.runtime.agentId,\n                content: {\n                    text: tweet.text,\n                    url: tweet.permanentUrl,\n                    imageUrls: tweet.photos?.map(photo => photo.url) || [],\n                    inReplyTo: tweet.inReplyToStatusId\n                        ? stringToUuid(\n                              tweet.inReplyToStatusId +\n                                  \"-\" +\n                                  this.runtime.agentId\n                          )\n                        : undefined,\n                },\n                userId: userIdUUID,\n                roomId,\n                createdAt: tweet.timestamp * 1000,\n            };\n            this.client.saveRequestMessage(message, state);\n        }\n\n        // get usernames into str\n        const validTargetUsersStr =\n            this.client.twitterConfig.TWITTER_TARGET_USERS.join(\",\");\n\n        const shouldRespondContext = composeContext({\n            state,\n            template:\n                this.runtime.character.templates\n                    ?.twitterShouldRespondTemplate ||\n                this.runtime.character?.templates?.shouldRespondTemplate ||\n                twitterShouldRespondTemplate(validTargetUsersStr),\n        });\n\n        const shouldRespond = await generateShouldRespond({\n            runtime: this.runtime,\n            context: shouldRespondContext,\n            modelClass: ModelClass.MEDIUM,\n        });\n\n        // Promise<\"RESPOND\" | \"IGNORE\" | \"STOP\" | null> {\n        if (shouldRespond !== \"RESPOND\") {\n            elizaLogger.log(\"Not responding to message\");\n            return { text: \"Response Decision:\", action: shouldRespond };\n        }\n\n        const context = composeContext({\n            state: {\n                ...state,\n                // Convert actionNames array to string\n                actionNames: Array.isArray(state.actionNames)\n                    ? state.actionNames.join(', ')\n                    : state.actionNames || '',\n                actions: Array.isArray(state.actions)\n                    ? state.actions.join('\\n')\n                    : state.actions || '',\n                // Ensure character examples are included\n                characterPostExamples: this.runtime.character.messageExamples\n                    ? this.runtime.character.messageExamples\n                        .map(example =>\n                            example.map(msg =>\n                                `${msg.user}: ${msg.content.text}${msg.content.action ? ` [Action: ${msg.content.action}]` : ''}`\n                            ).join('\\n')\n                        ).join('\\n\\n')\n                    : '',\n            },\n            template:\n                this.runtime.character.templates\n                    ?.twitterMessageHandlerTemplate ||\n                this.runtime.character?.templates?.messageHandlerTemplate ||\n                twitterMessageHandlerTemplate,\n        });\n\n        const response = await generateMessageResponse({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.LARGE,\n        });\n\n        const removeQuotes = (str: string) =>\n            str.replace(/^['\"](.*)['\"]$/, \"$1\");\n\n        const stringId = stringToUuid(tweet.id + \"-\" + this.runtime.agentId);\n\n        response.inReplyTo = stringId;\n\n        response.text = removeQuotes(response.text);\n\n        if (response.text) {\n            if (this.isDryRun) {\n                elizaLogger.info(\n                    `Dry run: Selected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\\nAgent's Output:\\n${response.text}`\n                );\n            } else {\n                try {\n                    const callback: HandlerCallback = async (\n                        response: Content,\n                        tweetId?: string\n                    ) => {\n                        const memories = await sendTweet(\n                            this.client,\n                            response,\n                            message.roomId,\n                            this.client.twitterConfig.TWITTER_USERNAME,\n                            tweetId || tweet.id\n                        );\n                        return memories;\n                    };\n\n                    const action = this.runtime.actions.find((a) => a.name === response.action);\n                    const shouldSuppressInitialMessage = action?.suppressInitialMessage;\n\n                    let responseMessages = [];\n\n                    if (!shouldSuppressInitialMessage) {\n                        responseMessages = await callback(response);\n                    } else {\n                        responseMessages = [{\n                            id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                            userId: this.runtime.agentId,\n                            agentId: this.runtime.agentId,\n                            content: response,\n                            roomId: message.roomId,\n                            embedding: getEmbeddingZeroVector(),\n                            createdAt: Date.now(),\n                        }];\n                    }\n\n                    state = (await this.runtime.updateRecentMessageState(\n                        state\n                    )) as State;\n\n                    for (const responseMessage of responseMessages) {\n                        if (\n                            responseMessage ===\n                            responseMessages[responseMessages.length - 1]\n                        ) {\n                            responseMessage.content.action = response.action;\n                        } else {\n                            responseMessage.content.action = \"CONTINUE\";\n                        }\n                        await this.runtime.messageManager.createMemory(\n                            responseMessage\n                        );\n                    }\n\n                    const responseTweetId =\n                    responseMessages[responseMessages.length - 1]?.content\n                        ?.tweetId;\n\n                    await this.runtime.processActions(\n                        message,\n                        responseMessages,\n                        state,\n                        (response: Content) => {\n                            return callback(response, responseTweetId);\n                        }\n                    );\n\n                    const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${tweet.id} - ${tweet.username}: ${tweet.text}\\nAgent's Output:\\n${response.text}`;\n\n                    await this.runtime.cacheManager.set(\n                        `twitter/tweet_generation_${tweet.id}.txt`,\n                        responseInfo\n                    );\n                    await wait();\n                } catch (error) {\n                    elizaLogger.error(`Error sending response tweet: ${error}`);\n                }\n            }\n        }\n    }\n\n    async buildConversationThread(\n        tweet: Tweet,\n        maxReplies = 10\n    ): Promise<Tweet[]> {\n        const thread: Tweet[] = [];\n        const visited: Set<string> = new Set();\n\n        async function processThread(currentTweet: Tweet, depth = 0) {\n            elizaLogger.log(\"Processing tweet:\", {\n                id: currentTweet.id,\n                inReplyToStatusId: currentTweet.inReplyToStatusId,\n                depth: depth,\n            });\n\n            if (!currentTweet) {\n                elizaLogger.log(\"No current tweet found for thread building\");\n                return;\n            }\n\n            if (depth >= maxReplies) {\n                elizaLogger.log(\"Reached maximum reply depth\", depth);\n                return;\n            }\n\n            // Handle memory storage\n            const memory = await this.runtime.messageManager.getMemoryById(\n                stringToUuid(currentTweet.id + \"-\" + this.runtime.agentId)\n            );\n            if (!memory) {\n                const roomId = stringToUuid(\n                    currentTweet.conversationId + \"-\" + this.runtime.agentId\n                );\n                const userId = stringToUuid(currentTweet.userId);\n\n                await this.runtime.ensureConnection(\n                    userId,\n                    roomId,\n                    currentTweet.username,\n                    currentTweet.name,\n                    \"twitter\"\n                );\n\n                this.runtime.messageManager.createMemory({\n                    id: stringToUuid(\n                        currentTweet.id + \"-\" + this.runtime.agentId\n                    ),\n                    agentId: this.runtime.agentId,\n                    content: {\n                        text: currentTweet.text,\n                        source: \"twitter\",\n                        url: currentTweet.permanentUrl,\n                        imageUrls: currentTweet.photos?.map(photo => photo.url) || [],\n                        inReplyTo: currentTweet.inReplyToStatusId\n                            ? stringToUuid(\n                                  currentTweet.inReplyToStatusId +\n                                      \"-\" +\n                                      this.runtime.agentId\n                              )\n                            : undefined,\n                    },\n                    createdAt: currentTweet.timestamp * 1000,\n                    roomId,\n                    userId:\n                        currentTweet.userId === this.twitterUserId\n                            ? this.runtime.agentId\n                            : stringToUuid(currentTweet.userId),\n                    embedding: getEmbeddingZeroVector(),\n                });\n            }\n\n            if (visited.has(currentTweet.id)) {\n                elizaLogger.log(\"Already visited tweet:\", currentTweet.id);\n                return;\n            }\n\n            visited.add(currentTweet.id);\n            thread.unshift(currentTweet);\n\n            if (currentTweet.inReplyToStatusId) {\n                elizaLogger.log(\n                    \"Fetching parent tweet:\",\n                    currentTweet.inReplyToStatusId\n                );\n                try {\n                    const parentTweet = await this.twitterClient.getTweet(\n                        currentTweet.inReplyToStatusId\n                    );\n\n                    if (parentTweet) {\n                        elizaLogger.log(\"Found parent tweet:\", {\n                            id: parentTweet.id,\n                            text: parentTweet.text?.slice(0, 50),\n                        });\n                        await processThread(parentTweet, depth + 1);\n                    } else {\n                        elizaLogger.log(\n                            \"No parent tweet found for:\",\n                            currentTweet.inReplyToStatusId\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.log(\"Error fetching parent tweet:\", {\n                        tweetId: currentTweet.inReplyToStatusId,\n                        error,\n                    });\n                }\n            } else {\n                elizaLogger.log(\n                    \"Reached end of reply chain at:\",\n                    currentTweet.id\n                );\n            }\n        }\n\n        // Need to bind this context for the inner function\n        await processThread.bind(this)(tweet, 0);\n\n        return thread;\n    }\n}","import type { Tweet } from \"agent-twitter-client\";\nimport { getEmbeddingZeroVector } from \"@elizaos/core\";\nimport type { Content, Memory, UUID } from \"@elizaos/core\";\nimport { stringToUuid } from \"@elizaos/core\";\nimport type { ClientBase } from \"./base\";\nimport { elizaLogger } from \"@elizaos/core\";\nimport type { Media } from \"@elizaos/core\";\nimport fs from \"fs\";\nimport path from \"path\";\nimport { MediaData } from \"./types\";\n\nexport const wait = (minTime = 1000, maxTime = 3000) => {\n    const waitTime =\n        Math.floor(Math.random() * (maxTime - minTime + 1)) + minTime;\n    return new Promise((resolve) => setTimeout(resolve, waitTime));\n};\n\nexport const isValidTweet = (tweet: Tweet): boolean => {\n    // Filter out tweets with too many hashtags, @s, or $ signs, probably spam or garbage\n    const hashtagCount = (tweet.text?.match(/#/g) || []).length;\n    const atCount = (tweet.text?.match(/@/g) || []).length;\n    const dollarSignCount = (tweet.text?.match(/\\$/g) || []).length;\n    const totalCount = hashtagCount + atCount + dollarSignCount;\n\n    return (\n        hashtagCount <= 1 &&\n        atCount <= 2 &&\n        dollarSignCount <= 1 &&\n        totalCount <= 3\n    );\n};\n\nexport async function buildConversationThread(\n    tweet: Tweet,\n    client: ClientBase,\n    maxReplies = 10\n): Promise<Tweet[]> {\n    const thread: Tweet[] = [];\n    const visited: Set<string> = new Set();\n\n    async function processThread(currentTweet: Tweet, depth = 0) {\n        elizaLogger.debug(\"Processing tweet:\", {\n            id: currentTweet.id,\n            inReplyToStatusId: currentTweet.inReplyToStatusId,\n            depth: depth,\n        });\n\n        if (!currentTweet) {\n            elizaLogger.debug(\"No current tweet found for thread building\");\n            return;\n        }\n\n        // Stop if we've reached our reply limit\n        if (depth >= maxReplies) {\n            elizaLogger.debug(\"Reached maximum reply depth\", depth);\n            return;\n        }\n\n        // Handle memory storage\n        const memory = await client.runtime.messageManager.getMemoryById(\n            stringToUuid(currentTweet.id + \"-\" + client.runtime.agentId)\n        );\n        if (!memory) {\n            const roomId = stringToUuid(\n                currentTweet.conversationId + \"-\" + client.runtime.agentId\n            );\n            const userId = stringToUuid(currentTweet.userId);\n\n            await client.runtime.ensureConnection(\n                userId,\n                roomId,\n                currentTweet.username,\n                currentTweet.name,\n                \"twitter\"\n            );\n\n            await client.runtime.messageManager.createMemory({\n                id: stringToUuid(\n                    currentTweet.id + \"-\" + client.runtime.agentId\n                ),\n                agentId: client.runtime.agentId,\n                content: {\n                    text: currentTweet.text,\n                    source: \"twitter\",\n                    url: currentTweet.permanentUrl,\n                    imageUrls: currentTweet.photos.map((p) => p.url) || [],\n                    inReplyTo: currentTweet.inReplyToStatusId\n                        ? stringToUuid(\n                              currentTweet.inReplyToStatusId +\n                                  \"-\" +\n                                  client.runtime.agentId\n                          )\n                        : undefined,\n                },\n                createdAt: currentTweet.timestamp * 1000,\n                roomId,\n                userId:\n                    currentTweet.userId === client.profile.id\n                        ? client.runtime.agentId\n                        : stringToUuid(currentTweet.userId),\n                embedding: getEmbeddingZeroVector(),\n            });\n        }\n\n        if (visited.has(currentTweet.id)) {\n            elizaLogger.debug(\"Already visited tweet:\", currentTweet.id);\n            return;\n        }\n\n        visited.add(currentTweet.id);\n        thread.unshift(currentTweet);\n\n        elizaLogger.debug(\"Current thread state:\", {\n            length: thread.length,\n            currentDepth: depth,\n            tweetId: currentTweet.id,\n        });\n\n        // If there's a parent tweet, fetch and process it\n        if (currentTweet.inReplyToStatusId) {\n            elizaLogger.debug(\n                \"Fetching parent tweet:\",\n                currentTweet.inReplyToStatusId\n            );\n            try {\n                const parentTweet = await client.twitterClient.getTweet(\n                    currentTweet.inReplyToStatusId\n                );\n\n                if (parentTweet) {\n                    elizaLogger.debug(\"Found parent tweet:\", {\n                        id: parentTweet.id,\n                        text: parentTweet.text?.slice(0, 50),\n                    });\n                    await processThread(parentTweet, depth + 1);\n                } else {\n                    elizaLogger.debug(\n                        \"No parent tweet found for:\",\n                        currentTweet.inReplyToStatusId\n                    );\n                }\n            } catch (error) {\n                elizaLogger.error(\"Error fetching parent tweet:\", {\n                    tweetId: currentTweet.inReplyToStatusId,\n                    error,\n                });\n            }\n        } else {\n            elizaLogger.debug(\n                \"Reached end of reply chain at:\",\n                currentTweet.id\n            );\n        }\n    }\n\n    await processThread(tweet, 0);\n\n    elizaLogger.debug(\"Final thread built:\", {\n        totalTweets: thread.length,\n        tweetIds: thread.map((t) => ({\n            id: t.id,\n            text: t.text?.slice(0, 50),\n        })),\n    });\n\n    return thread;\n}\n\nexport async function fetchMediaData(\n    attachments: Media[]\n): Promise<MediaData[]> {\n    return Promise.all(\n        attachments.map(async (attachment: Media) => {\n            if (/^(http|https):\\/\\//.test(attachment.url)) {\n                // Handle HTTP URLs\n                const response = await fetch(attachment.url);\n                if (!response.ok) {\n                    throw new Error(`Failed to fetch file: ${attachment.url}`);\n                }\n                const mediaBuffer = Buffer.from(await response.arrayBuffer());\n                const mediaType = attachment.contentType;\n                return { data: mediaBuffer, mediaType };\n            } else if (fs.existsSync(attachment.url)) {\n                // Handle local file paths\n                const mediaBuffer = await fs.promises.readFile(\n                    path.resolve(attachment.url)\n                );\n                const mediaType = attachment.contentType;\n                return { data: mediaBuffer, mediaType };\n            } else {\n                throw new Error(\n                    `File not found: ${attachment.url}. Make sure the path is correct.`\n                );\n            }\n        })\n    );\n}\n\nexport async function sendTweet(\n    client: ClientBase,\n    content: Content,\n    roomId: UUID,\n    twitterUsername: string,\n    inReplyTo: string\n): Promise<Memory[]> {\n    const maxTweetLength = client.twitterConfig.MAX_TWEET_LENGTH;\n    const isLongTweet = maxTweetLength > 280;\n\n    const tweetChunks = splitTweetContent(content.text, maxTweetLength);\n    const sentTweets: Tweet[] = [];\n    let previousTweetId = inReplyTo;\n\n    for (const chunk of tweetChunks) {\n        let mediaData = null;\n\n        if (content.attachments && content.attachments.length > 0) {\n            mediaData = await fetchMediaData(content.attachments);\n        }\n\n        const cleanChunk = deduplicateMentions(chunk.trim())\n\n        const result = await client.requestQueue.add(async () =>\n            isLongTweet\n                ? client.twitterClient.sendLongTweet(\n                      cleanChunk,\n                      previousTweetId,\n                      mediaData\n                  )\n                : client.twitterClient.sendTweet(\n                      cleanChunk,\n                      previousTweetId,\n                      mediaData\n                  )\n        );\n\n        const body = await result.json();\n        const tweetResult = isLongTweet\n            ? body?.data?.notetweet_create?.tweet_results?.result\n            : body?.data?.create_tweet?.tweet_results?.result;\n\n        // if we have a response\n        if (tweetResult) {\n            // Parse the response\n            const finalTweet: Tweet = {\n                id: tweetResult.rest_id,\n                text: tweetResult.legacy.full_text,\n                conversationId: tweetResult.legacy.conversation_id_str,\n                timestamp:\n                    new Date(tweetResult.legacy.created_at).getTime() / 1000,\n                userId: tweetResult.legacy.user_id_str,\n                inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\n                permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\n                hashtags: [],\n                mentions: [],\n                photos: [],\n                thread: [],\n                urls: [],\n                videos: [],\n            };\n            sentTweets.push(finalTweet);\n            previousTweetId = finalTweet.id;\n        } else {\n            elizaLogger.error(\"Error sending tweet chunk:\", {\n                chunk,\n                response: body,\n            });\n        }\n\n        // Wait a bit between tweets to avoid rate limiting issues\n        await wait(1000, 2000);\n    }\n\n    const memories: Memory[] = sentTweets.map((tweet) => ({\n        id: stringToUuid(tweet.id + \"-\" + client.runtime.agentId),\n        agentId: client.runtime.agentId,\n        userId: client.runtime.agentId,\n        content: {\n            tweetId: tweet.id,\n            text: tweet.text,\n            source: \"twitter\",\n            url: tweet.permanentUrl,\n            imageUrls: tweet.photos.map((p) => p.url) || [],\n            inReplyTo: tweet.inReplyToStatusId\n                ? stringToUuid(\n                      tweet.inReplyToStatusId + \"-\" + client.runtime.agentId\n                  )\n                : undefined,\n        },\n        roomId,\n        embedding: getEmbeddingZeroVector(),\n        createdAt: tweet.timestamp * 1000, \n    }));\n\n    return memories;\n}\n\nfunction splitTweetContent(content: string, maxLength: number): string[] {\n    const paragraphs = content.split(\"\\n\\n\").map((p) => p.trim());\n    const tweets: string[] = [];\n    let currentTweet = \"\";\n\n    for (const paragraph of paragraphs) {\n        if (!paragraph) continue;\n\n        if ((currentTweet + \"\\n\\n\" + paragraph).trim().length <= maxLength) {\n            if (currentTweet) {\n                currentTweet += \"\\n\\n\" + paragraph;\n            } else {\n                currentTweet = paragraph;\n            }\n        } else {\n            if (currentTweet) {\n                tweets.push(currentTweet.trim());\n            }\n            if (paragraph.length <= maxLength) {\n                currentTweet = paragraph;\n            } else {\n                // Split long paragraph into smaller chunks\n                const chunks = splitParagraph(paragraph, maxLength);\n                tweets.push(...chunks.slice(0, -1));\n                currentTweet = chunks[chunks.length - 1];\n            }\n        }\n    }\n\n    if (currentTweet) {\n        tweets.push(currentTweet.trim());\n    }\n\n    return tweets;\n}\n\nfunction extractUrls(paragraph: string): {\n    textWithPlaceholders: string;\n    placeholderMap: Map<string, string>;\n} {\n    // replace https urls with placeholder\n    const urlRegex = /https?:\\/\\/[^\\s]+/g;\n    const placeholderMap = new Map<string, string>();\n\n    let urlIndex = 0;\n    const textWithPlaceholders = paragraph.replace(urlRegex, (match) => {\n        // twitter url would be considered as 23 characters\n        // <<URL_CONSIDERER_23_1>> is also 23 characters\n        const placeholder = `<<URL_CONSIDERER_23_${urlIndex}>>`; // Placeholder without . ? ! etc\n        placeholderMap.set(placeholder, match);\n        urlIndex++;\n        return placeholder;\n    });\n\n    return { textWithPlaceholders, placeholderMap };\n}\n\nfunction splitSentencesAndWords(text: string, maxLength: number): string[] {\n    // Split by periods, question marks and exclamation marks\n    // Note that URLs in text have been replaced with `<<URL_xxx>>` and won't be split by dots\n    const sentences = text.match(/[^.!?]+[.!?]+|[^.!?]+$/g) || [text];\n    const chunks: string[] = [];\n    let currentChunk = \"\";\n\n    for (const sentence of sentences) {\n        if ((currentChunk + \" \" + sentence).trim().length <= maxLength) {\n            if (currentChunk) {\n                currentChunk += \" \" + sentence;\n            } else {\n                currentChunk = sentence;\n            }\n        } else {\n            // Can't fit more, push currentChunk to results\n            if (currentChunk) {\n                chunks.push(currentChunk.trim());\n            }\n\n            // If current sentence itself is less than or equal to maxLength\n            if (sentence.length <= maxLength) {\n                currentChunk = sentence;\n            } else {\n                // Need to split sentence by spaces\n                const words = sentence.split(\" \");\n                currentChunk = \"\";\n                for (const word of words) {\n                    if (\n                        (currentChunk + \" \" + word).trim().length <= maxLength\n                    ) {\n                        if (currentChunk) {\n                            currentChunk += \" \" + word;\n                        } else {\n                            currentChunk = word;\n                        }\n                    } else {\n                        if (currentChunk) {\n                            chunks.push(currentChunk.trim());\n                        }\n                        currentChunk = word;\n                    }\n                }\n            }\n        }\n    }\n\n    // Handle remaining content\n    if (currentChunk) {\n        chunks.push(currentChunk.trim());\n    }\n\n    return chunks;\n}\n\nfunction deduplicateMentions(paragraph: string) {\n    // Regex to match mentions at the beginning of the string\n  const mentionRegex = /^@(\\w+)(?:\\s+@(\\w+))*(\\s+|$)/;\n\n  // Find all matches\n  const matches = paragraph.match(mentionRegex);\n\n  if (!matches) {\n    return paragraph; // If no matches, return the original string\n  }\n\n  // Extract mentions from the match groups\n  let mentions = matches.slice(0, 1)[0].trim().split(' ')\n\n  // Deduplicate mentions\n  mentions = [...new Set(mentions)];\n\n  // Reconstruct the string with deduplicated mentions\n  const uniqueMentionsString = mentions.join(' ');\n\n  // Find where the mentions end in the original string\n  const endOfMentions = paragraph.indexOf(matches[0]) + matches[0].length;\n\n  // Construct the result by combining unique mentions with the rest of the string\n  return uniqueMentionsString + ' ' + paragraph.slice(endOfMentions);\n}\n\nfunction restoreUrls(\n    chunks: string[],\n    placeholderMap: Map<string, string>\n): string[] {\n    return chunks.map((chunk) => {\n        // Replace all <<URL_CONSIDERER_23_>> in chunk back to original URLs using regex\n        return chunk.replace(/<<URL_CONSIDERER_23_(\\d+)>>/g, (match) => {\n            const original = placeholderMap.get(match);\n            return original || match; // Return placeholder if not found (theoretically won't happen)\n        });\n    });\n}\n\nfunction splitParagraph(paragraph: string, maxLength: number): string[] {\n    // 1) Extract URLs and replace with placeholders\n    const { textWithPlaceholders, placeholderMap } = extractUrls(paragraph);\n\n    // 2) Use first section's logic to split by sentences first, then do secondary split\n    const splittedChunks = splitSentencesAndWords(\n        textWithPlaceholders,\n        maxLength\n    );\n\n    // 3) Replace placeholders back to original URLs\n    const restoredChunks = restoreUrls(splittedChunks, placeholderMap);\n\n    return restoredChunks;\n}\n","import type { Tweet } from \"agent-twitter-client\";\nimport {\n    composeContext,\n    generateText,\n    getEmbeddingZeroVector,\n    type IAgentRuntime,\n    ModelClass,\n    stringToUuid,\n    type TemplateType,\n    type UUID,\n    truncateToCompleteSentence,\n    parseJSONObjectFromText,\n    extractAttributes,\n    cleanJsonResponse,\n    HandlerCallback, Memory\n} from \"@elizaos/core\";\nimport { elizaLogger } from \"@elizaos/core\";\nimport type { ClientBase } from \"./base.ts\";\nimport { postActionResponseFooter } from \"@elizaos/core\";\nimport { generateTweetActions } from \"@elizaos/core\";\nimport { type IImageDescriptionService, ServiceType } from \"@elizaos/core\";\nimport { buildConversationThread, fetchMediaData } from \"./utils.ts\";\nimport { twitterMessageHandlerTemplate } from \"./interactions.ts\";\nimport { DEFAULT_MAX_TWEET_LENGTH } from \"./environment.ts\";\nimport {\n    Client,\n    Events,\n    GatewayIntentBits,\n    TextChannel,\n    Partials,\n} from \"discord.js\";\nimport type { Content, State } from \"@elizaos/core\";\nimport type { ActionResponse } from \"@elizaos/core\";\nimport { MediaData } from \"./types.ts\";\n\nconst MAX_TIMELINES_TO_FETCH = 15;\n\nconst twitterPostTemplate = `\n# Areas of Expertise\n{{knowledge}}\n\n# About {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{providers}}\n\n{{characterPostExamples}}\n\n{{postDirections}}\n\n\n# INSTRUCTIONS: Generate a post in the voice, style and perspective of {{agentName}} (@{{twitterUserName}}).\nYou MUST include an action if the current post text includes a prompt that is similar to one of the available actions mentioned here:\n{{actionNames}}\n{{actions}}\nPlace the action at the end, seprate by line break.\n\nWrite a post that is {{adjective}} about {{topic}} (without mentioning {{topic}} directly), from the perspective of {{agentName}}. Do not add commentary or acknowledge this request, just write the post.\nYour response should be 1, 2, or 3 sentences (choose the length at random).\nYour response should not contain any questions. Brief, concise statements only. The total character count MUST be less than {{maxTweetLength}}.\nNo emojis. Use \"  \" (double spaces) between statements if there are multiple statements in your response.\n\nGenerate an image of as character {{agentName}} to go along with the post,  decide between meme and no meme randoamlly.\n\nRespond with json of\n{\n\"text\": \"{tweet content}\"\n\"action\": \"{one of the actions that fit}\"\n}\n`;\n\n\nexport const twitterActionTemplate =\n    `\n# INSTRUCTIONS: Determine actions for {{agentName}} (@{{twitterUserName}}) based on:\n{{bio}}\n{{postDirections}}\n\nGuidelines:\n- ONLY engage with content that DIRECTLY relates to character's core interests\n- Direct mentions are priority IF they are on-topic\n- Skip ALL content that is:\n  - Off-topic or tangentially related\n  - From high-profile accounts unless explicitly relevant\n  - Generic/viral content without specific relevance\n  - Political/controversial unless central to character\n  - Promotional/marketing unless directly relevant\n\nActions (respond only with tags):\n[LIKE] - Perfect topic match AND aligns with character (9.8/10)\n[RETWEET] - Exceptional content that embodies character's expertise (9.5/10)\n[QUOTE] - Can add substantial domain expertise (9.5/10)\n[REPLY] - Can contribute meaningful, expert-level insight (9.5/10)\n\nTweet:\n{{currentTweet}}\n\n# Respond with qualifying action tags only. Default to NO action unless extremely confident of relevance.` +\n    postActionResponseFooter;\n\ninterface PendingTweet {\n    tweetTextForPosting: string;\n    roomId: UUID;\n    rawTweetContent: string;\n    discordMessageId: string;\n    channelId: string;\n    timestamp: number;\n}\n\ntype PendingTweetApprovalStatus = \"PENDING\" | \"APPROVED\" | \"REJECTED\";\n\nexport class TwitterPostClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    twitterUsername: string;\n    private isProcessing = false;\n    private lastProcessTime = 0;\n    private stopProcessingActions = false;\n    private isDryRun: boolean;\n    private discordClientForApproval: Client;\n    private approvalRequired = false;\n    private discordApprovalChannelId: string;\n    private approvalCheckInterval: number;\n\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n        this.twitterUsername = this.client.twitterConfig.TWITTER_USERNAME;\n        this.isDryRun = this.client.twitterConfig.TWITTER_DRY_RUN;\n\n        // Log configuration on initialization\n        elizaLogger.log(\"Twitter Client Configuration:\");\n        elizaLogger.log(`- Username: ${this.twitterUsername}`);\n        elizaLogger.log(\n            `- Dry Run Mode: ${this.isDryRun ? \"enabled\" : \"disabled\"}`\n        );\n\n        elizaLogger.log(\n            `- Enable Post: ${this.client.twitterConfig.ENABLE_TWITTER_POST_GENERATION ? \"enabled\" : \"disabled\"}`\n        );\n\n        elizaLogger.log(\n            `- Post Interval: ${this.client.twitterConfig.POST_INTERVAL_MIN}-${this.client.twitterConfig.POST_INTERVAL_MAX} minutes`\n        );\n        elizaLogger.log(\n            `- Action Processing: ${\n                this.client.twitterConfig.ENABLE_ACTION_PROCESSING\n                    ? \"enabled\"\n                    : \"disabled\"\n            }`\n        );\n        elizaLogger.log(\n            `- Action Interval: ${this.client.twitterConfig.ACTION_INTERVAL} minutes`\n        );\n        elizaLogger.log(\n            `- Post Immediately: ${\n                this.client.twitterConfig.POST_IMMEDIATELY\n                    ? \"enabled\"\n                    : \"disabled\"\n            }`\n        );\n        elizaLogger.log(\n            `- Search Enabled: ${\n                this.client.twitterConfig.TWITTER_SEARCH_ENABLE\n                    ? \"enabled\"\n                    : \"disabled\"\n            }`\n        );\n\n        const targetUsers = this.client.twitterConfig.TWITTER_TARGET_USERS;\n        if (targetUsers) {\n            elizaLogger.log(`- Target Users: ${targetUsers}`);\n        }\n\n        if (this.isDryRun) {\n            elizaLogger.log(\n                \"Twitter client initialized in dry run mode - no actual tweets should be posted\"\n            );\n        }\n\n        // Initialize Discord webhook\n        const approvalRequired: boolean =\n            this.runtime\n                .getSetting(\"TWITTER_APPROVAL_ENABLED\")\n                ?.toLocaleLowerCase() === \"true\";\n        if (approvalRequired) {\n            const discordToken = this.runtime.getSetting(\n                \"TWITTER_APPROVAL_DISCORD_BOT_TOKEN\"\n            );\n            const approvalChannelId = this.runtime.getSetting(\n                \"TWITTER_APPROVAL_DISCORD_CHANNEL_ID\"\n            );\n\n            const APPROVAL_CHECK_INTERVAL =\n                Number.parseInt(\n                    this.runtime.getSetting(\"TWITTER_APPROVAL_CHECK_INTERVAL\")\n                ) || 5 * 60 * 1000; // 5 minutes\n\n            this.approvalCheckInterval = APPROVAL_CHECK_INTERVAL;\n\n            if (!discordToken || !approvalChannelId) {\n                throw new Error(\n                    \"TWITTER_APPROVAL_DISCORD_BOT_TOKEN and TWITTER_APPROVAL_DISCORD_CHANNEL_ID are required for approval workflow\"\n                );\n            }\n\n            this.approvalRequired = true;\n            this.discordApprovalChannelId = approvalChannelId;\n\n            // Set up Discord client event handlers\n            this.setupDiscordClient();\n        }\n    }\n\n    private setupDiscordClient() {\n        this.discordClientForApproval = new Client({\n            intents: [\n                GatewayIntentBits.Guilds,\n                GatewayIntentBits.GuildMessages,\n                GatewayIntentBits.MessageContent,\n                GatewayIntentBits.GuildMessageReactions,\n            ],\n            partials: [Partials.Channel, Partials.Message, Partials.Reaction],\n        });\n        this.discordClientForApproval.once(\n            Events.ClientReady,\n            (readyClient) => {\n                elizaLogger.log(\n                    `Discord bot is ready as ${readyClient.user.tag}!`\n                );\n\n                // Generate invite link with required permissions\n                const invite = `https://discord.com/api/oauth2/authorize?client_id=${readyClient.user.id}&permissions=274877991936&scope=bot`;\n                // 274877991936 includes permissions for:\n                // - Send Messages\n                // - Read Messages/View Channels\n                // - Read Message History\n\n                elizaLogger.log(\n                    `Use this link to properly invite the Twitter Post Approval Discord bot: ${invite}`\n                );\n            }\n        );\n        // Login to Discord\n        this.discordClientForApproval.login(\n            this.runtime.getSetting(\"TWITTER_APPROVAL_DISCORD_BOT_TOKEN\")\n        );\n    }\n\n    async start() {\n        if (!this.client.profile) {\n            await this.client.init();\n        }\n\n        const generateNewTweetLoop = async () => {\n            const lastPost = await this.runtime.cacheManager.get<{\n                timestamp: number;\n            }>(\"twitter/\" + this.twitterUsername + \"/lastPost\");\n\n            const lastPostTimestamp = lastPost?.timestamp ?? 0;\n            const minMinutes = this.client.twitterConfig.POST_INTERVAL_MIN;\n            const maxMinutes = this.client.twitterConfig.POST_INTERVAL_MAX;\n            const randomMinutes =\n                Math.floor(Math.random() * (maxMinutes - minMinutes + 1)) +\n                minMinutes;\n            const delay = randomMinutes * 60 * 1000;\n\n            if (Date.now() > lastPostTimestamp + delay) {\n                await this.generateNewTweet();\n            }\n\n            setTimeout(() => {\n                generateNewTweetLoop(); // Set up next iteration\n            }, delay);\n\n            elizaLogger.log(`Next tweet scheduled in ${randomMinutes} minutes`);\n        };\n\n        const processActionsLoop = async () => {\n            const actionInterval = this.client.twitterConfig.ACTION_INTERVAL; // Defaults to 5 minutes\n\n            while (!this.stopProcessingActions) {\n                try {\n                    const results = await this.processTweetActions();\n                    if (results) {\n                        elizaLogger.log(`Processed ${results.length} tweets`);\n                        elizaLogger.log(\n                            `Next action processing scheduled in ${actionInterval} minutes`\n                        );\n                        // Wait for the full interval before next processing\n                        await new Promise(\n                            (resolve) =>\n                                setTimeout(resolve, actionInterval * 60 * 1000) // now in minutes\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.error(\n                        \"Error in action processing loop:\",\n                        error\n                    );\n                    // Add exponential backoff on error\n                    await new Promise((resolve) => setTimeout(resolve, 30000)); // Wait 30s on error\n                }\n            }\n        };\n\n        if (this.client.twitterConfig.POST_IMMEDIATELY) {\n            await this.generateNewTweet();\n        }\n\n        if (this.client.twitterConfig.ENABLE_TWITTER_POST_GENERATION) {\n            generateNewTweetLoop();\n            elizaLogger.log(\"Tweet generation loop started\");\n        }\n\n        if (this.client.twitterConfig.ENABLE_ACTION_PROCESSING) {\n            processActionsLoop().catch((error) => {\n                elizaLogger.error(\n                    \"Fatal error in process actions loop:\",\n                    error\n                );\n            });\n        }\n\n        // Start the pending tweet check loop if enabled\n        if (this.approvalRequired) this.runPendingTweetCheckLoop();\n    }\n\n    private runPendingTweetCheckLoop() {\n        setInterval(async () => {\n            await this.handlePendingTweet();\n        }, this.approvalCheckInterval);\n    }\n\n    createTweetObject(\n        tweetResult: any,\n        client: any,\n        twitterUsername: string\n    ): Tweet {\n        return {\n            id: tweetResult.rest_id,\n            name: client.profile.screenName,\n            username: client.profile.username,\n            text: tweetResult.legacy.full_text,\n            conversationId: tweetResult.legacy.conversation_id_str,\n            createdAt: tweetResult.legacy.created_at,\n            timestamp: new Date(tweetResult.legacy.created_at).getTime(),\n            userId: client.profile.id,\n            inReplyToStatusId: tweetResult.legacy.in_reply_to_status_id_str,\n            permanentUrl: `https://twitter.com/${twitterUsername}/status/${tweetResult.rest_id}`,\n            hashtags: [],\n            mentions: [],\n            photos: [],\n            thread: [],\n            urls: [],\n            videos: [],\n        } as Tweet;\n    }\n\n    async processAndCacheTweet(\n        runtime: IAgentRuntime,\n        client: ClientBase,\n        tweet: Tweet,\n        roomId: UUID,\n        rawTweetContent: string\n    ) {\n        // Cache the last post details\n        await runtime.cacheManager.set(\n            `twitter/${client.profile.username}/lastPost`,\n            {\n                id: tweet.id,\n                timestamp: Date.now(),\n            }\n        );\n\n        // Cache the tweet\n        await client.cacheTweet(tweet);\n\n        // Log the posted tweet\n        elizaLogger.log(`Tweet posted:\\n ${tweet.permanentUrl}`);\n\n        // Ensure the room and participant exist\n        await runtime.ensureRoomExists(roomId);\n        await runtime.ensureParticipantInRoom(runtime.agentId, roomId);\n\n        // Create a memory for the tweet\n        await runtime.messageManager.createMemory({\n            id: stringToUuid(tweet.id + \"-\" + runtime.agentId),\n            userId: runtime.agentId,\n            agentId: runtime.agentId,\n            content: {\n                text: rawTweetContent.trim(),\n                url: tweet.permanentUrl,\n                source: \"twitter\",\n            },\n            roomId,\n            embedding: getEmbeddingZeroVector(),\n            createdAt: tweet.timestamp,\n        });\n    }\n\n    async handleNoteTweet(\n        client: ClientBase,\n        content: string,\n        tweetId?: string,\n        mediaData?: MediaData[]\n    ) {\n        try {\n            const noteTweetResult = await client.requestQueue.add(\n                async () =>\n                    await client.twitterClient.sendNoteTweet(\n                        content,\n                        tweetId,\n                        mediaData\n                    )\n            );\n\n            if (noteTweetResult.errors && noteTweetResult.errors.length > 0) {\n                // Note Tweet failed due to authorization. Falling back to standard Tweet.\n                const truncateContent = truncateToCompleteSentence(\n                    content,\n                    this.client.twitterConfig.MAX_TWEET_LENGTH\n                );\n                return await this.sendStandardTweet(\n                    client,\n                    truncateContent,\n                    tweetId\n                );\n            } else {\n                return noteTweetResult.data.notetweet_create.tweet_results\n                    .result;\n            }\n        } catch (error) {\n            throw new Error(`Note Tweet failed: ${error}`);\n        }\n    }\n\n    async sendStandardTweet(\n        client: ClientBase,\n        content: string,\n        tweetId?: string,\n        mediaData?: MediaData[]\n    ) {\n        try {\n            const standardTweetResult = await client.requestQueue.add(\n                async () =>\n                    await client.twitterClient.sendTweet(\n                        content,\n                        tweetId,\n                        mediaData\n                    )\n            );\n            const body = await standardTweetResult.json();\n            if (!body?.data?.create_tweet?.tweet_results?.result) {\n                elizaLogger.error(\"Error sending tweet; Bad response:\", body);\n                return;\n            }\n            return body.data.create_tweet.tweet_results.result;\n        } catch (error) {\n            elizaLogger.error(\"Error sending standard Tweet:\", error);\n            throw error;\n        }\n    }\n\n    async postTweet(\n        runtime: IAgentRuntime,\n        client: ClientBase,\n        tweetTextForPosting: string,\n        roomId: UUID,\n        rawTweetContent: string,\n        twitterUsername: string,\n        mediaData?: MediaData[]\n    ) {\n        try {\n            elizaLogger.log(`Posting new tweet:\\n`);\n\n            let result;\n\n            if (tweetTextForPosting.length > DEFAULT_MAX_TWEET_LENGTH) {\n                result = await this.handleNoteTweet(\n                    client,\n                    tweetTextForPosting,\n                    undefined,\n                    mediaData\n                );\n            } else {\n                result = await this.sendStandardTweet(\n                    client,\n                    tweetTextForPosting,\n                    undefined,\n                    mediaData\n                );\n            }\n\n            const tweet = this.createTweetObject(\n                result,\n                client,\n                twitterUsername\n            );\n\n            await this.processAndCacheTweet(\n                runtime,\n                client,\n                tweet,\n                roomId,\n                rawTweetContent\n            );\n        } catch (error) {\n            elizaLogger.error(\"Error sending tweet:\", error);\n        }\n    }\n\n    /**\n     * Generates and posts a new tweet. If isDryRun is true, only logs what would have been posted.\n     */\n    async generateNewTweet() {\n        elizaLogger.log(\"Generating new tweet\");\n\n        try {\n          const roomId = stringToUuid(\n            \"twitter_generate_room-\" + this.client.profile.username\n          );\n          await this.runtime.ensureUserExists(\n            this.runtime.agentId,\n            this.client.profile.username,\n            this.runtime.character.name,\n            \"twitter\"\n          );\n      \n          const topics = this.runtime.character.topics.join(\", \");\n          const maxTweetLength = this.client.twitterConfig.MAX_TWEET_LENGTH;\n          const state = await this.runtime.composeState(\n            {\n              userId: this.runtime.agentId,\n              roomId: roomId,\n              agentId: this.runtime.agentId,\n              content: {\n                text: topics || \"\",\n                action: \"TWEET\",\n              },\n            },\n            {\n              twitterUserName: this.client.profile.username,\n              maxTweetLength,\n            }\n          );\n      \n          const context = composeContext({\n            state,\n            template:\n              this.runtime.character.templates?.twitterPostTemplate ||\n              twitterPostTemplate,\n          });\n      \n          elizaLogger.debug(\"generate post prompt:\\n\" + context);\n          const rawTweetContent = await generateText({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n          });\n      \n          // Parse the raw content as JSON (if possible)\n          const parsedResponse = parseJSONObjectFromText(rawTweetContent);\n      \n          // Determine the tweet text from the parsed response if available.\n          let tweetTextForPosting: string | null = parsedResponse?.text || null;\n          // Note: mediaData is now left undefined until after processActions.\n          let mediaData: any = undefined;\n      \n          // If tweet text isn’t set, try to extract it.\n          if (!tweetTextForPosting) {\n            const parsingText = extractAttributes(rawTweetContent, [\"text\"]).text;\n            if (parsingText) {\n              tweetTextForPosting = truncateToCompleteSentence(\n                parsingText,\n                maxTweetLength\n              );\n            }\n            elizaLogger.debug(\"Parsing text extracted:\", parsingText);\n          }\n      \n          // Define a callback matching the HandlerCallback signature.\n          const callback: HandlerCallback = async (\n            content: Content\n          ): Promise<Memory[]> => {\n            // In this callback we process attachments AFTER processing actions.\n            // Ensure tweet text is defined.\n\n            if (!tweetTextForPosting) {\n              tweetTextForPosting = rawTweetContent;\n            }\n      \n            // Truncate tweet text if a max length is specified.\n            if (maxTweetLength) {\n              tweetTextForPosting = truncateToCompleteSentence(\n                tweetTextForPosting,\n                maxTweetLength\n              );\n            }\n      \n            // Process attachments AFTER any actions.\n            if (content.attachments && content.attachments.length > 0) {\n              mediaData = await fetchMediaData(content.attachments);\n            }\n      \n            // Helper functions to clean the tweet text.\n            const removeQuotes = (str: string): string =>\n              str.replace(/^['\"](.*)['\"]$/, \"$1\");\n            const fixNewLines = (str: string): string =>\n              str.replaceAll(/\\\\n/g, \"\\n\\n\");\n      \n            // Final cleaning.\n            tweetTextForPosting = removeQuotes(fixNewLines(tweetTextForPosting));\n      \n            // If it's a dry run, simply log and return an empty array.\n            if (this.isDryRun) {\n              elizaLogger.info(\n                `Dry run: would have posted tweet: ${tweetTextForPosting}`\n              );\n              return [];\n            }\n      \n            try {\n              if (this.approvalRequired) {\n                elizaLogger.log(\n                  `Sending Tweet For Approval:\\n ${tweetTextForPosting}`\n                );\n                await this.sendForApproval(\n                  tweetTextForPosting,\n                  roomId,\n                  rawTweetContent\n                );\n                elizaLogger.log(\"Tweet sent for approval\");\n              } else {\n                elizaLogger.log(`Posting new tweet:\\n ${tweetTextForPosting}`);\n                this.postTweet(\n                  this.runtime,\n                  this.client,\n                  tweetTextForPosting,\n                  roomId,\n                  rawTweetContent,\n                  this.twitterUsername,\n                  mediaData\n                );\n              }\n            } catch (error) {\n            console.log(error)\n              elizaLogger.error(\"Error sending tweet:\", error);\n            }\n      \n            // Return an empty array to satisfy the HandlerCallback type.\n            return [];\n          };\n      \n          let tweet:Content = parsedResponse as Content;\n          // If an action is specified in the parsed response, process it first.\n          await this.runtime.processActions(\n              {\n                userId: this.runtime.agentId,\n                roomId: roomId,\n                agentId: this.runtime.agentId,\n                content: { text: parsedResponse.text, source: \"twitter\" },\n              },\n              [\n                {\n                  userId: this.runtime.agentId,\n                  roomId: roomId,\n                  agentId: this.runtime.agentId,\n                  content: {\n                    text: \"Ok, generating.\",\n                    action: parsedResponse.action,\n                  },\n                },\n              ],\n              state,\n              async (content:Content) => {\n                // message = newMessages;\n                elizaLogger.log(\"after generating\");\n\n                tweet = content;\n\n                return [];\n            }\n            );\n\n            await callback(tweet);\n\n\n         \n        } catch (error) {\n           console.log(error)\n          elizaLogger.error(\"Error generating new tweet:\", error);\n        }\n      }\n    private async generateTweetContent(\n        tweetState: any,\n        options?: {\n            template?: TemplateType;\n            context?: string;\n        }\n    ): Promise<Content> {\n        const context = composeContext({\n            state: tweetState,\n            template:\n                options?.template ||\n                this.runtime.character.templates?.twitterPostTemplate ||\n                twitterPostTemplate,\n        });\n\n        const response = await generateText({\n            runtime: this.runtime,\n            context: options?.context || context,\n            modelClass: ModelClass.SMALL,\n        });\n\n        elizaLogger.log(\"generate tweet content response:\\n\" + response);\n\n        // First clean up any markdown and newlines\n        const cleanedResponse = cleanJsonResponse(response);\n\n        let truncateContent = null;\n\n        // Try to parse as JSON first\n        const jsonResponse = parseJSONObjectFromText(cleanedResponse);\n        if (jsonResponse.text) {\n            truncateContent = truncateToCompleteSentence(\n                jsonResponse.text,\n                this.client.twitterConfig.MAX_TWEET_LENGTH\n            );\n        }\n        if (typeof jsonResponse === \"object\") {\n            const possibleContent =\n                jsonResponse.content ||\n                jsonResponse.message ||\n                jsonResponse.response;\n            if (possibleContent) {\n                truncateContent = truncateToCompleteSentence(\n                    possibleContent,\n                    this.client.twitterConfig.MAX_TWEET_LENGTH\n                );\n            }\n        }\n        else {\n\n        \n\n            // Try extracting text attribute\n            const parsingText = extractAttributes(cleanedResponse, [\"text\"]).text;\n            if (parsingText) {\n                truncateContent = truncateToCompleteSentence(\n                    parsingText,\n                    this.client.twitterConfig.MAX_TWEET_LENGTH\n                );\n            }\n\n            if (!truncateContent) {\n                // If not JSON or no valid content found, clean the raw text\n                truncateContent = truncateToCompleteSentence(\n                    cleanedResponse,\n                    this.client.twitterConfig.MAX_TWEET_LENGTH\n                );\n            }\n\n        }\n\n\n\n        jsonResponse.text = truncateContent;\n        let tweet:Content = jsonResponse as Content;\n\n        await this.runtime.processActions(\n            {\n              userId: this.runtime.agentId,\n              roomId: tweetState.roomId,\n              agentId: this.runtime.agentId,\n              content: { text: jsonResponse.text, source: \"twitter\" },\n            },\n            [\n              {\n                userId: this.runtime.agentId,\n                roomId: tweetState.roomId,\n                agentId: this.runtime.agentId,\n                content: {\n                  text: \"Ok, generating.\",\n                  action: jsonResponse.action,\n                },\n              },\n            ],\n            tweetState,\n            async (content:Content) => {\n              // message = newMessages;\n              elizaLogger.log(\"after generating\");\n\n              tweet = content;\n\n              return [];\n          }\n          );\n\n\n\n        return tweet;\n    }\n\n    /**\n     * Processes tweet actions (likes, retweets, quotes, replies). If isDryRun is true,\n     * only simulates and logs actions without making API calls.\n     */\n    private async processTweetActions() {\n        if (this.isProcessing) {\n            elizaLogger.log(\"Already processing tweet actions, skipping\");\n            return null;\n        }\n\n        try {\n            this.isProcessing = true;\n            this.lastProcessTime = Date.now();\n\n            elizaLogger.log(\"Processing tweet actions\");\n\n            await this.runtime.ensureUserExists(\n                this.runtime.agentId,\n                this.twitterUsername,\n                this.runtime.character.name,\n                \"twitter\"\n            );\n\n            const timelines = await this.client.fetchTimelineForActions(\n                MAX_TIMELINES_TO_FETCH\n            );\n            const maxActionsProcessing =\n                this.client.twitterConfig.MAX_ACTIONS_PROCESSING;\n            const processedTimelines = [];\n\n            for (const tweet of timelines) {\n                try {\n                    // Skip if we've already processed this tweet\n                    const memory =\n                        await this.runtime.messageManager.getMemoryById(\n                            stringToUuid(tweet.id + \"-\" + this.runtime.agentId)\n                        );\n                    if (memory) {\n                        elizaLogger.log(\n                            `Already processed tweet ID: ${tweet.id}`\n                        );\n                        continue;\n                    }\n\n                    const roomId = stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    );\n\n                    const tweetState = await this.runtime.composeState(\n                        {\n                            userId: this.runtime.agentId,\n                            roomId,\n                            agentId: this.runtime.agentId,\n                            content: { text: \"\", action: \"\" },\n                        },\n                        {\n                            twitterUserName: this.twitterUsername,\n                            currentTweet: `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})\\nText: ${tweet.text}`,\n                        }\n                    );\n\n                    const actionContext = composeContext({\n                        state: tweetState,\n                        template:\n                            this.runtime.character.templates\n                                ?.twitterActionTemplate ||\n                            twitterActionTemplate,\n                    });\n\n                    const actionResponse = await generateTweetActions({\n                        runtime: this.runtime,\n                        context: actionContext,\n                        modelClass: ModelClass.SMALL,\n                    });\n\n                    if (!actionResponse) {\n                        elizaLogger.log(\n                            `No valid actions generated for tweet ${tweet.id}`\n                        );\n                        continue;\n                    }\n                    processedTimelines.push({\n                        tweet: tweet,\n                        actionResponse: actionResponse,\n                        tweetState: tweetState,\n                        roomId: roomId,\n                    });\n                } catch (error) {\n                    elizaLogger.error(\n                        `Error processing tweet ${tweet.id}:`,\n                        error\n                    );\n                    continue;\n                }\n            }\n\n            const sortProcessedTimeline = (arr: typeof processedTimelines) => {\n                return arr.sort((a, b) => {\n                    // Count the number of true values in the actionResponse object\n                    const countTrue = (obj: typeof a.actionResponse) =>\n                        Object.values(obj).filter(Boolean).length;\n\n                    const countA = countTrue(a.actionResponse);\n                    const countB = countTrue(b.actionResponse);\n\n                    // Primary sort by number of true values\n                    if (countA !== countB) {\n                        return countB - countA;\n                    }\n\n                    // Secondary sort by the \"like\" property\n                    if (a.actionResponse.like !== b.actionResponse.like) {\n                        return a.actionResponse.like ? -1 : 1;\n                    }\n\n                    // Tertiary sort keeps the remaining objects with equal weight\n                    return 0;\n                });\n            };\n            // Sort the timeline based on the action decision score,\n            // then slice the results according to the environment variable to limit the number of actions per cycle.\n            const sortedTimelines = sortProcessedTimeline(\n                processedTimelines\n            ).slice(0, maxActionsProcessing);\n\n            return this.processTimelineActions(sortedTimelines); // Return results array to indicate completion\n        } catch (error) {\n            elizaLogger.error(\"Error in processTweetActions:\", error);\n            throw error;\n        } finally {\n            this.isProcessing = false;\n        }\n    }\n\n    /**\n     * Processes a list of timelines by executing the corresponding tweet actions.\n     * Each timeline includes the tweet, action response, tweet state, and room context.\n     * Results are returned for tracking completed actions.\n     *\n     * @param timelines - Array of objects containing tweet details, action responses, and state information.\n     * @returns A promise that resolves to an array of results with details of executed actions.\n     */\n    private async processTimelineActions(\n        timelines: {\n            tweet: Tweet;\n            actionResponse: ActionResponse;\n            tweetState: State;\n            roomId: UUID;\n        }[]\n    ): Promise<\n        {\n            tweetId: string;\n            actionResponse: ActionResponse;\n            executedActions: string[];\n        }[]\n    > {\n        const results = [];\n        for (const timeline of timelines) {\n            const { actionResponse, tweetState, roomId, tweet } = timeline;\n            try {\n                const executedActions: string[] = [];\n                // Execute actions\n                if (actionResponse.like) {\n                    if (this.isDryRun) {\n                        elizaLogger.info(\n                            `Dry run: would have liked tweet ${tweet.id}`\n                        );\n                        executedActions.push(\"like (dry run)\");\n                    } else {\n                        try {\n                            await this.client.twitterClient.likeTweet(tweet.id);\n                            executedActions.push(\"like\");\n                            elizaLogger.log(`Liked tweet ${tweet.id}`);\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error liking tweet ${tweet.id}:`,\n                                error\n                            );\n                        }\n                    }\n                }\n\n                if (actionResponse.retweet) {\n                    if (this.isDryRun) {\n                        elizaLogger.info(\n                            `Dry run: would have retweeted tweet ${tweet.id}`\n                        );\n                        executedActions.push(\"retweet (dry run)\");\n                    } else {\n                        try {\n                            await this.client.twitterClient.retweet(tweet.id);\n                            executedActions.push(\"retweet\");\n                            elizaLogger.log(`Retweeted tweet ${tweet.id}`);\n                        } catch (error) {\n                            elizaLogger.error(\n                                `Error retweeting tweet ${tweet.id}:`,\n                                error\n                            );\n                        }\n                    }\n                }\n\n                if (actionResponse.quote) {\n                    try {\n                        // Build conversation thread for context\n                        const thread = await buildConversationThread(\n                            tweet,\n                            this.client\n                        );\n                        const formattedConversation = thread\n                            .map(\n                                (t) =>\n                                    `@${t.username} (${new Date(\n                                        t.timestamp * 1000\n                                    ).toLocaleString()}): ${t.text}`\n                            )\n                            .join(\"\\n\\n\");\n\n                        // Generate image descriptions if present\n                        const imageDescriptions = [];\n                        if (tweet.photos?.length > 0) {\n                            elizaLogger.log(\n                                \"Processing images in tweet for context\"\n                            );\n                            for (const photo of tweet.photos) {\n                                const description = await this.runtime\n                                    .getService<IImageDescriptionService>(\n                                        ServiceType.IMAGE_DESCRIPTION\n                                    )\n                                    .describeImage(photo.url);\n                                imageDescriptions.push(description);\n                            }\n                        }\n\n                        // Handle quoted tweet if present\n                        let quotedContent = \"\";\n                        if (tweet.quotedStatusId) {\n                            try {\n                                const quotedTweet =\n                                    await this.client.twitterClient.getTweet(\n                                        tweet.quotedStatusId\n                                    );\n                                if (quotedTweet) {\n                                    quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n                                }\n                            } catch (error) {\n                                elizaLogger.error(\n                                    \"Error fetching quoted tweet:\",\n                                    error\n                                );\n                            }\n                        }\n\n                        // Compose rich state with all context\n                        const enrichedState = await this.runtime.composeState(\n                            {\n                                userId: this.runtime.agentId,\n                                roomId: stringToUuid(\n                                    tweet.conversationId +\n                                        \"-\" +\n                                        this.runtime.agentId\n                                ),\n                                agentId: this.runtime.agentId,\n                                content: {\n                                    text: tweet.text,\n                                    action: \"QUOTE\",\n                                },\n                            },\n                            {\n                                twitterUserName: this.twitterUsername,\n                                currentPost: `From @${tweet.username}: ${tweet.text}`,\n                                formattedConversation,\n                                imageContext:\n                                    imageDescriptions.length > 0\n                                        ? `\\nImages in Tweet:\\n${imageDescriptions\n                                              .map(\n                                                  (desc, i) =>\n                                                      `Image ${i + 1}: ${desc}`\n                                              )\n                                              .join(\"\\n\")}`\n                                        : \"\",\n                                quotedContent,\n                            }\n                        );\n\n                        const quoteContent = await this.generateTweetContent(\n                            enrichedState,\n                            {\n                                template:\n                                    this.runtime.character.templates\n                                        ?.twitterMessageHandlerTemplate ||\n                                    twitterMessageHandlerTemplate,\n                            }\n                        );\n\n                        if (!quoteContent) {\n                            elizaLogger.error(\n                                \"Failed to generate valid quote tweet content\"\n                            );\n                            return;\n                        }\n\n                        elizaLogger.log(\n                            \"Generated quote tweet content:\",\n                            quoteContent.text\n                        );\n                        // Check for dry run mode\n                        if (this.isDryRun) {\n                            elizaLogger.info(\n                                `Dry run: A quote tweet for tweet ID ${tweet.id} would have been posted with the following content: \"${quoteContent.text}\".`\n                            );\n                            executedActions.push(\"quote (dry run)\");\n                        } else {\n                            // Send the tweet through request queue\n                            const result = await this.client.requestQueue.add(\n                                async () =>\n                                    await this.client.twitterClient.sendQuoteTweet(\n                                        quoteContent.text,\n                                        tweet.id\n                                    )\n                            );\n\n                            const body = await result.json();\n\n                            if (\n                                body?.data?.create_tweet?.tweet_results?.result\n                            ) {\n                                elizaLogger.log(\n                                    \"Successfully posted quote tweet\"\n                                );\n                                executedActions.push(\"quote\");\n\n                                // Cache generation context for debugging\n                                await this.runtime.cacheManager.set(\n                                    `twitter/quote_generation_${tweet.id}.txt`,\n                                    `Context:\\n${enrichedState}\\n\\nGenerated Quote:\\n${quoteContent.text}`\n                                );\n                            } else {\n                                elizaLogger.error(\n                                    \"Quote tweet creation failed:\",\n                                    body\n                                );\n                            }\n                        }\n                    } catch (error) {\n                        elizaLogger.error(\n                            \"Error in quote tweet generation:\",\n                            error\n                        );\n                    }\n                }\n\n                if (actionResponse.reply) {\n                    try {\n                        await this.handleTextOnlyReply(\n                            tweet,\n                            tweetState,\n                            executedActions\n                        );\n                    } catch (error) {\n                        elizaLogger.error(\n                            `Error replying to tweet ${tweet.id}:`,\n                            error\n                        );\n                    }\n                }\n\n                // Add these checks before creating memory\n                await this.runtime.ensureRoomExists(roomId);\n                await this.runtime.ensureUserExists(\n                    stringToUuid(tweet.userId),\n                    tweet.username,\n                    tweet.name,\n                    \"twitter\"\n                );\n                await this.runtime.ensureParticipantInRoom(\n                    this.runtime.agentId,\n                    roomId\n                );\n\n                if (!this.isDryRun) {\n                    // Then create the memory\n                    await this.runtime.messageManager.createMemory({\n                        id: stringToUuid(tweet.id + \"-\" + this.runtime.agentId),\n                        userId: stringToUuid(tweet.userId),\n                        content: {\n                            text: tweet.text,\n                            url: tweet.permanentUrl,\n                            source: \"twitter\",\n                            action: executedActions.join(\",\"),\n                        },\n                        agentId: this.runtime.agentId,\n                        roomId,\n                        embedding: getEmbeddingZeroVector(),\n                        createdAt: tweet.timestamp * 1000,\n                    });\n                }\n\n                results.push({\n                    tweetId: tweet.id,\n                    actionResponse: actionResponse,\n                    executedActions,\n                });\n            } catch (error) {\n                elizaLogger.error(`Error processing tweet ${tweet.id}:`, error);\n                continue;\n            }\n        }\n\n        return results;\n    }\n\n    /**\n     * Handles text-only replies to tweets. If isDryRun is true, only logs what would\n     * have been replied without making API calls.\n     */\n    private async handleTextOnlyReply(\n        tweet: Tweet,\n        tweetState: any,\n        executedActions: string[]\n    ) {\n        try {\n            // Build conversation thread for context\n            const thread = await buildConversationThread(tweet, this.client);\n            const formattedConversation = thread\n                .map(\n                    (t) =>\n                        `@${t.username} (${new Date(\n                            t.timestamp * 1000\n                        ).toLocaleString()}): ${t.text}`\n                )\n                .join(\"\\n\\n\");\n\n            // Generate image descriptions if present\n            const imageDescriptions = [];\n            if (tweet.photos?.length > 0) {\n                elizaLogger.log(\"Processing images in tweet for context\");\n                for (const photo of tweet.photos) {\n                    const description = await this.runtime\n                        .getService<IImageDescriptionService>(\n                            ServiceType.IMAGE_DESCRIPTION\n                        )\n                        .describeImage(photo.url);\n                    imageDescriptions.push(description);\n                }\n            }\n\n            // Handle quoted tweet if present\n            let quotedContent = \"\";\n            if (tweet.quotedStatusId) {\n                try {\n                    const quotedTweet =\n                        await this.client.twitterClient.getTweet(\n                            tweet.quotedStatusId\n                        );\n                    if (quotedTweet) {\n                        quotedContent = `\\nQuoted Tweet from @${quotedTweet.username}:\\n${quotedTweet.text}`;\n                    }\n                } catch (error) {\n                    elizaLogger.error(\"Error fetching quoted tweet:\", error);\n                }\n            }\n\n            // Compose rich state with all context\n            const enrichedState = await this.runtime.composeState(\n                {\n                    userId: this.runtime.agentId,\n                    roomId: stringToUuid(\n                        tweet.conversationId + \"-\" + this.runtime.agentId\n                    ),\n                    agentId: this.runtime.agentId,\n                    content: { text: tweet.text, action: \"\" },\n                },\n                {\n                    twitterUserName: this.twitterUsername,\n                    currentPost: `From @${tweet.username}: ${tweet.text}`,\n                    formattedConversation,\n                    imageContext:\n                        imageDescriptions.length > 0\n                            ? `\\nImages in Tweet:\\n${imageDescriptions\n                                  .map((desc, i) => `Image ${i + 1}: ${desc}`)\n                                  .join(\"\\n\")}`\n                            : \"\",\n                    quotedContent,\n                }\n            );\n\n            // Generate and clean the reply content\n            const replyTweet = await this.generateTweetContent(enrichedState, {\n                template:\n                    this.runtime.character.templates\n                        ?.twitterMessageHandlerTemplate ||\n                    twitterMessageHandlerTemplate,\n            });\n\n            if (!replyTweet) {\n                elizaLogger.error(\"Failed to generate valid reply content\");\n                return;\n            }\n\n            if (this.isDryRun) {\n                elizaLogger.info(\n                    `Dry run: reply to tweet ${tweet.id} would have been: ${replyTweet.text}`\n                );\n                executedActions.push(\"reply (dry run)\");\n                return;\n            }\n\n            elizaLogger.debug(\"Final reply text to be sent:\", replyTweet.text);\n\n            let result;\n            let mediaData: any = undefined;\n\n            // Process attachments AFTER any actions.\n            if (replyTweet.attachments && replyTweet.attachments.length > 0) {\n                mediaData = await fetchMediaData(replyTweet.attachments);\n            }\n    \n            if (replyTweet.text.length > DEFAULT_MAX_TWEET_LENGTH) {\n                result = await this.handleNoteTweet(\n                    this.client,\n                    replyTweet.text,\n                    tweet.id,\n                    mediaData\n                );\n            } else {\n                result = await this.sendStandardTweet(\n                    this.client,\n                    replyTweet.text,\n                    tweet.id,\n                    mediaData\n                );\n            }\n\n            if (result) {\n                elizaLogger.log(\"Successfully posted reply tweet\");\n                executedActions.push(\"reply\");\n\n                // Cache generation context for debugging\n                await this.runtime.cacheManager.set(\n                    `twitter/reply_generation_${tweet.id}.txt`,\n                    `Context:\\n${enrichedState}\\n\\nGenerated Reply:\\n${replyTweet.text}`\n                );\n            } else {\n                elizaLogger.error(\"Tweet reply creation failed\");\n            }\n        } catch (error) {\n            elizaLogger.error(\"Error in handleTextOnlyReply:\", error);\n        }\n    }\n\n    async stop() {\n        this.stopProcessingActions = true;\n    }\n\n    private async sendForApproval(\n        tweetTextForPosting: string,\n        roomId: UUID,\n        rawTweetContent: string\n    ): Promise<string | null> {\n        try {\n            const embed = {\n                title: \"New Tweet Pending Approval\",\n                description: tweetTextForPosting,\n                fields: [\n                    {\n                        name: \"Character\",\n                        value: this.client.profile.username,\n                        inline: true,\n                    },\n                    {\n                        name: \"Length\",\n                        value: tweetTextForPosting.length.toString(),\n                        inline: true,\n                    },\n                ],\n                footer: {\n                    text: \"Reply with '👍' to post or '❌' to discard, This will automatically expire and remove after 24 hours if no response received\",\n                },\n                timestamp: new Date().toISOString(),\n            };\n\n            const channel = await this.discordClientForApproval.channels.fetch(\n                this.discordApprovalChannelId\n            );\n\n            if (!channel || !(channel instanceof TextChannel)) {\n                throw new Error(\"Invalid approval channel\");\n            }\n\n            const message = await channel.send({ embeds: [embed] });\n\n            // Store the pending tweet\n            const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n            const currentPendingTweets =\n                (await this.runtime.cacheManager.get<PendingTweet[]>(\n                    pendingTweetsKey\n                )) || [];\n            // Add new pending tweet\n            currentPendingTweets.push({\n                tweetTextForPosting,\n                roomId,\n                rawTweetContent,\n                discordMessageId: message.id,\n                channelId: this.discordApprovalChannelId,\n                timestamp: Date.now(),\n            });\n\n            // Store updated array\n            await this.runtime.cacheManager.set(\n                pendingTweetsKey,\n                currentPendingTweets\n            );\n\n            return message.id;\n        } catch (error) {\n            elizaLogger.error(\n                \"Error Sending Twitter Post Approval Request:\",\n                error\n            );\n            return null;\n        }\n    }\n\n    private async checkApprovalStatus(\n        discordMessageId: string\n    ): Promise<PendingTweetApprovalStatus> {\n        try {\n            // Fetch message and its replies from Discord\n            const channel = await this.discordClientForApproval.channels.fetch(\n                this.discordApprovalChannelId\n            );\n\n            elizaLogger.log(`channel ${JSON.stringify(channel)}`);\n\n            if (!(channel instanceof TextChannel)) {\n                elizaLogger.error(\"Invalid approval channel\");\n                return \"PENDING\";\n            }\n\n            // Fetch the original message and its replies\n            const message = await channel.messages.fetch(discordMessageId);\n\n            // Look for thumbs up reaction ('👍')\n            const thumbsUpReaction = message.reactions.cache.find(\n                (reaction) => reaction.emoji.name === \"👍\"\n            );\n\n            // Look for reject reaction ('❌')\n            const rejectReaction = message.reactions.cache.find(\n                (reaction) => reaction.emoji.name === \"❌\"\n            );\n\n            // Check if the reaction exists and has reactions\n            if (rejectReaction) {\n                const count = rejectReaction.count;\n                if (count > 0) {\n                    return \"REJECTED\";\n                }\n            }\n\n            // Check if the reaction exists and has reactions\n            if (thumbsUpReaction) {\n                // You might want to check for specific users who can approve\n                // For now, we'll return true if anyone used thumbs up\n                const count = thumbsUpReaction.count;\n                if (count > 0) {\n                    return \"APPROVED\";\n                }\n            }\n\n            return \"PENDING\";\n        } catch (error) {\n            elizaLogger.error(\"Error checking approval status:\", error);\n            return \"PENDING\";\n        }\n    }\n\n    private async cleanupPendingTweet(discordMessageId: string) {\n        const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n        const currentPendingTweets =\n            (await this.runtime.cacheManager.get<PendingTweet[]>(\n                pendingTweetsKey\n            )) || [];\n\n        // Remove the specific tweet\n        const updatedPendingTweets = currentPendingTweets.filter(\n            (tweet) => tweet.discordMessageId !== discordMessageId\n        );\n\n        if (updatedPendingTweets.length === 0) {\n            await this.runtime.cacheManager.delete(pendingTweetsKey);\n        } else {\n            await this.runtime.cacheManager.set(\n                pendingTweetsKey,\n                updatedPendingTweets\n            );\n        }\n    }\n\n    private async handlePendingTweet() {\n        elizaLogger.log(\"Checking Pending Tweets...\");\n        const pendingTweetsKey = `twitter/${this.client.profile.username}/pendingTweet`;\n        const pendingTweets =\n            (await this.runtime.cacheManager.get<PendingTweet[]>(\n                pendingTweetsKey\n            )) || [];\n\n        for (const pendingTweet of pendingTweets) {\n            // Check if tweet is older than 24 hours\n            const isExpired =\n                Date.now() - pendingTweet.timestamp > 24 * 60 * 60 * 1000;\n\n            if (isExpired) {\n                elizaLogger.log(\"Pending tweet expired, cleaning up\");\n\n                // Notify on Discord about expiration\n                try {\n                    const channel =\n                        await this.discordClientForApproval.channels.fetch(\n                            pendingTweet.channelId\n                        );\n                    if (channel instanceof TextChannel) {\n                        const originalMessage = await channel.messages.fetch(\n                            pendingTweet.discordMessageId\n                        );\n                        await originalMessage.reply(\n                            \"This tweet approval request has expired (24h timeout).\"\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.error(\n                        \"Error sending expiration notification:\",\n                        error\n                    );\n                }\n\n                await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n                return;\n            }\n\n            // Check approval status\n            elizaLogger.log(\"Checking approval status...\");\n            const approvalStatus: PendingTweetApprovalStatus =\n                await this.checkApprovalStatus(pendingTweet.discordMessageId);\n\n            if (approvalStatus === \"APPROVED\") {\n                elizaLogger.log(\"Tweet Approved, Posting\");\n                await this.postTweet(\n                    this.runtime,\n                    this.client,\n                    pendingTweet.tweetTextForPosting,\n                    pendingTweet.roomId,\n                    pendingTweet.rawTweetContent,\n                    this.twitterUsername\n                );\n\n                // Notify on Discord about posting\n                try {\n                    const channel =\n                        await this.discordClientForApproval.channels.fetch(\n                            pendingTweet.channelId\n                        );\n                    if (channel instanceof TextChannel) {\n                        const originalMessage = await channel.messages.fetch(\n                            pendingTweet.discordMessageId\n                        );\n                        await originalMessage.reply(\n                            \"Tweet has been posted successfully! ✅\"\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.error(\n                        \"Error sending post notification:\",\n                        error\n                    );\n                }\n\n                await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n            } else if (approvalStatus === \"REJECTED\") {\n                elizaLogger.log(\"Tweet Rejected, Cleaning Up\");\n                await this.cleanupPendingTweet(pendingTweet.discordMessageId);\n                // Notify about Rejection of Tweet\n                try {\n                    const channel =\n                        await this.discordClientForApproval.channels.fetch(\n                            pendingTweet.channelId\n                        );\n                    if (channel instanceof TextChannel) {\n                        const originalMessage = await channel.messages.fetch(\n                            pendingTweet.discordMessageId\n                        );\n                        await originalMessage.reply(\n                            \"Tweet has been rejected! ❌\"\n                        );\n                    }\n                } catch (error) {\n                    elizaLogger.error(\n                        \"Error sending rejection notification:\",\n                        error\n                    );\n                }\n            }\n        }\n    }\n}\n","import { SearchMode } from \"agent-twitter-client\";\nimport { composeContext, elizaLogger } from \"@elizaos/core\";\nimport { generateMessageResponse, generateText } from \"@elizaos/core\";\nimport { messageCompletionFooter } from \"@elizaos/core\";\nimport {\n    type Content,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type IImageDescriptionService,\n    ModelClass,\n    ServiceType,\n    type State,\n} from \"@elizaos/core\";\nimport { stringToUuid } from \"@elizaos/core\";\nimport type { ClientBase } from \"./base\";\nimport { buildConversationThread, sendTweet, wait } from \"./utils.ts\";\n\nconst twitterSearchTemplate =\n    `{{timeline}}\n\n{{providers}}\n\nRecent interactions between {{agentName}} and other users:\n{{recentPostInteractions}}\n\nAbout {{agentName}} (@{{twitterUserName}}):\n{{bio}}\n{{lore}}\n{{topics}}\n\n{{postDirections}}\n\n{{recentPosts}}\n\n# Task: Respond to the following post in the style and perspective of {{agentName}} (aka @{{twitterUserName}}). Write a {{adjective}} response for {{agentName}} to say directly in response to the post. don't generalize.\n{{currentPost}}\n\nIMPORTANT: Your response CANNOT be longer than 20 words.\nAim for 1-2 short sentences maximum. Be concise and direct.\n\nYour response should not contain any questions. Brief, concise statements only. No emojis. Use \\\\n\\\\n (double spaces) between statements.\n\n` + messageCompletionFooter;\n\nexport class TwitterSearchClient {\n    client: ClientBase;\n    runtime: IAgentRuntime;\n    twitterUsername: string;\n    private respondedTweets: Set<string> = new Set();\n\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.runtime = runtime;\n        this.twitterUsername = this.client.twitterConfig.TWITTER_USERNAME;\n    }\n\n    async start() {\n        this.engageWithSearchTermsLoop();\n    }\n\n    private engageWithSearchTermsLoop() {\n        this.engageWithSearchTerms().then();\n        const randomMinutes = Math.floor(Math.random() * (120 - 60 + 1)) + 60;\n        elizaLogger.log(\n            `Next twitter search scheduled in ${randomMinutes} minutes`\n        );\n        setTimeout(\n            () => this.engageWithSearchTermsLoop(),\n            randomMinutes * 60 * 1000\n        );\n    }\n\n    private async engageWithSearchTerms() {\n        elizaLogger.log(\"Engaging with search terms\");\n        try {\n            const searchTerm = [...this.runtime.character.topics][\n                Math.floor(Math.random() * this.runtime.character.topics.length)\n            ];\n\n            elizaLogger.log(\"Fetching search tweets\");\n            // TODO: we wait 5 seconds here to avoid getting rate limited on startup, but we should queue\n            await new Promise((resolve) => setTimeout(resolve, 5000));\n            const recentTweets = await this.client.fetchSearchTweets(\n                searchTerm,\n                20,\n                SearchMode.Top\n            );\n            elizaLogger.log(\"Search tweets fetched\");\n\n            const homeTimeline = await this.client.fetchHomeTimeline(50);\n\n            await this.client.cacheTimeline(homeTimeline);\n\n            const formattedHomeTimeline =\n                `# ${this.runtime.character.name}'s Home Timeline\\n\\n` +\n                homeTimeline\n                    .map((tweet) => {\n                        return `ID: ${tweet.id}\\nFrom: ${tweet.name} (@${tweet.username})${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : \"\"}\\nText: ${tweet.text}\\n---\\n`;\n                    })\n                    .join(\"\\n\");\n\n            // randomly slice .tweets down to 20\n            const slicedTweets = recentTweets.tweets\n                .sort(() => Math.random() - 0.5)\n                .slice(0, 20);\n\n            if (slicedTweets.length === 0) {\n                elizaLogger.log(\n                    \"No valid tweets found for the search term\",\n                    searchTerm\n                );\n                return;\n            }\n\n            const prompt = `\n  Here are some tweets related to the search term \"${searchTerm}\":\n\n  ${[...slicedTweets, ...homeTimeline]\n      .filter((tweet) => {\n          // ignore tweets where any of the thread tweets contain a tweet by the bot\n          const thread = tweet.thread;\n          const botTweet = thread.find(\n              (t) => t.username === this.twitterUsername\n          );\n          return !botTweet;\n      })\n      .map(\n          (tweet) => `\n    ID: ${tweet.id}${tweet.inReplyToStatusId ? ` In reply to: ${tweet.inReplyToStatusId}` : \"\"}\n    From: ${tweet.name} (@${tweet.username})\n    Text: ${tweet.text}\n  `\n      )\n      .join(\"\\n\")}\n\n  Which tweet is the most interesting and relevant for Ruby to reply to? Please provide only the ID of the tweet in your response.\n  Notes:\n    - Respond to English tweets only\n    - Respond to tweets that don't have a lot of hashtags, links, URLs or images\n    - Respond to tweets that are not retweets\n    - Respond to tweets where there is an easy exchange of ideas to have with the user\n    - ONLY respond with the ID of the tweet`;\n\n            const mostInterestingTweetResponse = await generateText({\n                runtime: this.runtime,\n                context: prompt,\n                modelClass: ModelClass.SMALL,\n            });\n\n            const tweetId = mostInterestingTweetResponse.trim();\n            const selectedTweet = slicedTweets.find(\n                (tweet) =>\n                    tweet.id.toString().includes(tweetId) ||\n                    tweetId.includes(tweet.id.toString())\n            );\n\n            if (!selectedTweet) {\n                elizaLogger.warn(\"No matching tweet found for the selected ID\");\n                elizaLogger.log(\"Selected tweet ID:\", tweetId);\n                return;\n            }\n\n            elizaLogger.log(\"Selected tweet to reply to:\", selectedTweet?.text);\n\n            if (selectedTweet.username === this.twitterUsername) {\n                elizaLogger.log(\"Skipping tweet from bot itself\");\n                return;\n            }\n\n            const conversationId = selectedTweet.conversationId;\n            const roomId = stringToUuid(\n                conversationId + \"-\" + this.runtime.agentId\n            );\n\n            const userIdUUID = stringToUuid(selectedTweet.userId as string);\n\n            await this.runtime.ensureConnection(\n                userIdUUID,\n                roomId,\n                selectedTweet.username,\n                selectedTweet.name,\n                \"twitter\"\n            );\n\n            // crawl additional conversation tweets, if there are any\n            await buildConversationThread(selectedTweet, this.client);\n\n            const message = {\n                id: stringToUuid(selectedTweet.id + \"-\" + this.runtime.agentId),\n                agentId: this.runtime.agentId,\n                content: {\n                    text: selectedTweet.text,\n                    url: selectedTweet.permanentUrl,\n                    inReplyTo: selectedTweet.inReplyToStatusId\n                        ? stringToUuid(\n                              selectedTweet.inReplyToStatusId +\n                                  \"-\" +\n                                  this.runtime.agentId\n                          )\n                        : undefined,\n                },\n                userId: userIdUUID,\n                roomId,\n                // Timestamps are in seconds, but we need them in milliseconds\n                createdAt: selectedTweet.timestamp * 1000,\n            };\n\n            if (!message.content.text) {\n                elizaLogger.warn(\"Returning: No response text found\");\n                return;\n            }\n\n            // Fetch replies and retweets\n            const replies = selectedTweet.thread;\n            const replyContext = replies\n                .filter((reply) => reply.username !== this.twitterUsername)\n                .map((reply) => `@${reply.username}: ${reply.text}`)\n                .join(\"\\n\");\n\n            let tweetBackground = \"\";\n            if (selectedTweet.isRetweet) {\n                const originalTweet = await this.client.requestQueue.add(() =>\n                    this.client.twitterClient.getTweet(selectedTweet.id)\n                );\n                tweetBackground = `Retweeting @${originalTweet.username}: ${originalTweet.text}`;\n            }\n\n            // Generate image descriptions using GPT-4 vision API\n            const imageDescriptions = [];\n            for (const photo of selectedTweet.photos) {\n                const description = await this.runtime\n                    .getService<IImageDescriptionService>(\n                        ServiceType.IMAGE_DESCRIPTION\n                    )\n                    .describeImage(photo.url);\n                imageDescriptions.push(description);\n            }\n\n            let state = await this.runtime.composeState(message, {\n                twitterClient: this.client.twitterClient,\n                twitterUserName: this.twitterUsername,\n                timeline: formattedHomeTimeline,\n                tweetContext: `${tweetBackground}\n\n  Original Post:\n  By @${selectedTweet.username}\n  ${selectedTweet.text}${replyContext.length > 0 && `\\nReplies to original post:\\n${replyContext}`}\n  ${`Original post text: ${selectedTweet.text}`}\n  ${selectedTweet.urls.length > 0 ? `URLs: ${selectedTweet.urls.join(\", \")}\\n` : \"\"}${imageDescriptions.length > 0 ? `\\nImages in Post (Described): ${imageDescriptions.join(\", \")}\\n` : \"\"}\n  `,\n            });\n\n            await this.client.saveRequestMessage(message, state as State);\n\n            const context = composeContext({\n                state,\n                template:\n                    this.runtime.character.templates?.twitterSearchTemplate ||\n                    twitterSearchTemplate,\n            });\n\n            const responseContent = await generateMessageResponse({\n                runtime: this.runtime,\n                context,\n                modelClass: ModelClass.LARGE,\n            });\n\n            responseContent.inReplyTo = message.id;\n\n            const response = responseContent;\n\n            if (!response.text) {\n                elizaLogger.warn(\"Returning: No response text found\");\n                return;\n            }\n\n            elizaLogger.log(\n                `Bot would respond to tweet ${selectedTweet.id} with: ${response.text}`\n            );\n            try {\n                const callback: HandlerCallback = async (response: Content) => {\n                    const memories = await sendTweet(\n                        this.client,\n                        response,\n                        message.roomId,\n                        this.twitterUsername,\n                        selectedTweet.id\n                    );\n                    return memories;\n                };\n\n                const responseMessages = await callback(responseContent);\n\n                state = await this.runtime.updateRecentMessageState(state);\n\n                for (const responseMessage of responseMessages) {\n                    await this.runtime.messageManager.createMemory(\n                        responseMessage,\n                        false\n                    );\n                }\n\n                state = await this.runtime.updateRecentMessageState(state);\n\n                await this.runtime.evaluate(message, state);\n\n                await this.runtime.processActions(\n                    message,\n                    responseMessages,\n                    state,\n                    callback\n                );\n\n                this.respondedTweets.add(selectedTweet.id);\n                const responseInfo = `Context:\\n\\n${context}\\n\\nSelected Post: ${selectedTweet.id} - ${selectedTweet.username}: ${selectedTweet.text}\\nAgent's Output:\\n${response.text}`;\n\n                await this.runtime.cacheManager.set(\n                    `twitter/tweet_generation_${selectedTweet.id}.txt`,\n                    responseInfo\n                );\n\n                await wait();\n            } catch (error) {\n                console.error(`Error sending response post: ${error}`);\n            }\n        } catch (error) {\n            console.error(\"Error engaging with search terms:\", error);\n        }\n    }\n}\n","import {\n    elizaLogger,\n    type IAgentRuntime,\n    composeContext,\n    generateText,\n    ModelClass,\n    ServiceType,\n    type ITranscriptionService,\n    type TwitterSpaceDecisionOptions,\n} from \"@elizaos/core\";\nimport type { ClientBase } from \"./base\";\nimport {\n    type Scraper,\n    Space,\n    type SpaceConfig,\n    RecordToDiskPlugin,\n    IdleMonitorPlugin,\n    type SpeakerRequest,\n} from \"agent-twitter-client\";\nimport { SttTtsPlugin } from \"./plugins/SttTtsSpacesPlugin.ts\";\n\ninterface CurrentSpeakerState {\n    userId: string;\n    sessionUUID: string;\n    username: string;\n    startTime: number;\n}\n\n/**\n * Generate short filler text via GPT\n */\nasync function generateFiller(\n    runtime: IAgentRuntime,\n    fillerType: string\n): Promise<string> {\n    try {\n        const context = composeContext({\n            state: { fillerType },\n            template: `\n# INSTRUCTIONS:\nYou are generating a short filler message for a Twitter Space. The filler type is \"{{fillerType}}\".\nKeep it brief, friendly, and relevant. No more than two sentences.\nOnly return the text, no additional formatting.\n\n---\n`,\n        });\n        const output = await generateText({\n            runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n        return output.trim();\n    } catch (err) {\n        elizaLogger.error(\"[generateFiller] Error generating filler:\", err);\n        return \"\";\n    }\n}\n\n/**\n * Speak a filler message if STT/TTS plugin is available. Sleep a bit after TTS to avoid cutoff.\n */\nasync function speakFiller(\n    runtime: IAgentRuntime,\n    sttTtsPlugin: SttTtsPlugin | undefined,\n    fillerType: string,\n    sleepAfterMs = 3000\n): Promise<void> {\n    if (!sttTtsPlugin) return;\n    const text = await generateFiller(runtime, fillerType);\n    if (!text) return;\n\n    elizaLogger.log(`[Space] Filler (${fillerType}) => ${text}`);\n    await sttTtsPlugin.speakText(text);\n\n    if (sleepAfterMs > 0) {\n        await new Promise((res) => setTimeout(res, sleepAfterMs));\n    }\n}\n\n/**\n * Generate topic suggestions via GPT if no topics are configured\n */\nasync function generateTopicsIfEmpty(\n    runtime: IAgentRuntime\n): Promise<string[]> {\n    try {\n        const context = composeContext({\n            state: {},\n            template: `\n# INSTRUCTIONS:\nPlease generate 5 short topic ideas for a Twitter Space about technology or random interesting subjects.\nReturn them as a comma-separated list, no additional formatting or numbering.\n\nExample:\n\"AI Advances, Futuristic Gadgets, Space Exploration, Quantum Computing, Digital Ethics\"\n---\n`,\n        });\n        const response = await generateText({\n            runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n        const topics = response\n            .split(\",\")\n            .map((t) => t.trim())\n            .filter(Boolean);\n        return topics.length ? topics : [\"Random Tech Chat\", \"AI Thoughts\"];\n    } catch (err) {\n        elizaLogger.error(\"[generateTopicsIfEmpty] GPT error =>\", err);\n        return [\"Random Tech Chat\", \"AI Thoughts\"];\n    }\n}\n\n/**\n * Main class: manage a Twitter Space with N speakers max, speaker queue, filler messages, etc.\n */\nexport class TwitterSpaceClient {\n    private runtime: IAgentRuntime;\n    private client: ClientBase;\n    private scraper: Scraper;\n    private isSpaceRunning = false;\n    private currentSpace?: Space;\n    private spaceId?: string;\n    private startedAt?: number;\n    private checkInterval?: NodeJS.Timeout;\n    private lastSpaceEndedAt?: number;\n    private sttTtsPlugin?: SttTtsPlugin;\n\n    /**\n     * We now store an array of active speakers, not just 1\n     */\n    private activeSpeakers: CurrentSpeakerState[] = [];\n    private speakerQueue: SpeakerRequest[] = [];\n\n    private decisionOptions: TwitterSpaceDecisionOptions;\n\n    constructor(client: ClientBase, runtime: IAgentRuntime) {\n        this.client = client;\n        this.scraper = client.twitterClient;\n        this.runtime = runtime;\n\n        const charSpaces = runtime.character.twitterSpaces || {};\n        this.decisionOptions = {\n            maxSpeakers: charSpaces.maxSpeakers ?? 1,\n            topics: charSpaces.topics ?? [],\n            typicalDurationMinutes: charSpaces.typicalDurationMinutes ?? 30,\n            idleKickTimeoutMs: charSpaces.idleKickTimeoutMs ?? 5 * 60_000,\n            minIntervalBetweenSpacesMinutes:\n                charSpaces.minIntervalBetweenSpacesMinutes ?? 60,\n            businessHoursOnly: charSpaces.businessHoursOnly ?? false,\n            randomChance: charSpaces.randomChance ?? 0.3,\n            enableIdleMonitor: charSpaces.enableIdleMonitor !== false,\n            enableSttTts: charSpaces.enableSttTts !== false,\n            enableRecording: charSpaces.enableRecording !== false,\n            voiceId:\n                charSpaces.voiceId ||\n                runtime.character.settings.voice.model ||\n                \"Xb7hH8MSUJpSbSDYk0k2\",\n            sttLanguage: charSpaces.sttLanguage || \"en\",\n            speakerMaxDurationMs: charSpaces.speakerMaxDurationMs ?? 4 * 60_000,\n        };\n    }\n\n    /**\n     * Periodic check to launch or manage space\n     */\n    public async startPeriodicSpaceCheck() {\n        elizaLogger.log(\"[Space] Starting periodic check routine...\");\n\n        // For instance:\n        const intervalMsWhenIdle = 5 * 60_000; // 5 minutes if no Space is running\n        const intervalMsWhenRunning = 5_000; // 5 seconds if a Space IS running\n\n        const routine = async () => {\n            try {\n                if (!this.isSpaceRunning) {\n                    // Space not running => check if we should launch\n                    const launch = await this.shouldLaunchSpace();\n                    if (launch) {\n                        const config = await this.generateSpaceConfig();\n                        await this.startSpace(config);\n                    }\n                    // Plan next iteration with a slower pace\n                    this.checkInterval = setTimeout(\n                        routine,\n                        this.isSpaceRunning\n                            ? intervalMsWhenRunning\n                            : intervalMsWhenIdle\n                    );\n                } else {\n                    // Space is running => manage it more frequently\n                    await this.manageCurrentSpace();\n                    // Plan next iteration with a faster pace\n                    this.checkInterval = setTimeout(\n                        routine,\n                        intervalMsWhenRunning\n                    );\n                }\n            } catch (error) {\n                elizaLogger.error(\"[Space] Error in routine =>\", error);\n                // In case of error, still schedule next iteration\n                this.checkInterval = setTimeout(routine, intervalMsWhenIdle);\n            }\n        };\n\n        routine();\n    }\n\n    stopPeriodicCheck() {\n        if (this.checkInterval) {\n            clearTimeout(this.checkInterval);\n            this.checkInterval = undefined;\n        }\n    }\n\n    private async shouldLaunchSpace(): Promise<boolean> {\n        // Random chance\n        const r = Math.random();\n        if (r > (this.decisionOptions.randomChance ?? 0.3)) {\n            elizaLogger.log(\"[Space] Random check => skip launching\");\n            return false;\n        }\n        // Business hours\n        if (this.decisionOptions.businessHoursOnly) {\n            const hour = new Date().getUTCHours();\n            if (hour < 9 || hour >= 17) {\n                elizaLogger.log(\"[Space] Out of business hours => skip\");\n                return false;\n            }\n        }\n        // Interval\n        const now = Date.now();\n        if (this.lastSpaceEndedAt) {\n            const minIntervalMs =\n                (this.decisionOptions.minIntervalBetweenSpacesMinutes ?? 60) *\n                60_000;\n            if (now - this.lastSpaceEndedAt < minIntervalMs) {\n                elizaLogger.log(\"[Space] Too soon since last space => skip\");\n                return false;\n            }\n        }\n\n        elizaLogger.log(\"[Space] Deciding to launch a new Space...\");\n        return true;\n    }\n\n    private async generateSpaceConfig(): Promise<SpaceConfig> {\n        if (\n            !this.decisionOptions.topics ||\n            this.decisionOptions.topics.length === 0\n        ) {\n            const newTopics = await generateTopicsIfEmpty(this.client.runtime);\n            this.decisionOptions.topics = newTopics;\n        }\n\n        let chosenTopic = \"Random Tech Chat\";\n        if (\n            this.decisionOptions.topics &&\n            this.decisionOptions.topics.length > 0\n        ) {\n            chosenTopic =\n                this.decisionOptions.topics[\n                    Math.floor(\n                        Math.random() * this.decisionOptions.topics.length\n                    )\n                ];\n        }\n\n        return {\n            mode: \"INTERACTIVE\",\n            title: chosenTopic,\n            description: `Discussion about ${chosenTopic}`,\n            languages: [\"en\"],\n        };\n    }\n\n    public async startSpace(config: SpaceConfig) {\n        elizaLogger.log(\"[Space] Starting a new Twitter Space...\");\n\n        try {\n            this.currentSpace = new Space(this.scraper);\n            this.isSpaceRunning = false;\n            this.spaceId = undefined;\n            this.startedAt = Date.now();\n\n            // Reset states\n            this.activeSpeakers = [];\n            this.speakerQueue = [];\n\n            // Retrieve keys\n            const elevenLabsKey =\n                this.runtime.getSetting(\"ELEVENLABS_XI_API_KEY\") || \"\";\n\n            const broadcastInfo = await this.currentSpace.initialize(config);\n            this.spaceId = broadcastInfo.room_id;\n            // Plugins\n            if (this.decisionOptions.enableRecording) {\n                elizaLogger.log(\"[Space] Using RecordToDiskPlugin\");\n                this.currentSpace.use(new RecordToDiskPlugin());\n            }\n\n            if (this.decisionOptions.enableSttTts) {\n                elizaLogger.log(\"[Space] Using SttTtsPlugin\");\n                const sttTts = new SttTtsPlugin();\n                this.sttTtsPlugin = sttTts;\n                this.currentSpace.use(sttTts, {\n                    runtime: this.runtime,\n                    client: this.client,\n                    spaceId: this.spaceId,\n                    elevenLabsApiKey: elevenLabsKey,\n                    voiceId: this.decisionOptions.voiceId,\n                    sttLanguage: this.decisionOptions.sttLanguage,\n                    transcriptionService:\n                        this.client.runtime.getService<ITranscriptionService>(\n                            ServiceType.TRANSCRIPTION\n                        ),\n                });\n            }\n\n            if (this.decisionOptions.enableIdleMonitor) {\n                elizaLogger.log(\"[Space] Using IdleMonitorPlugin\");\n                this.currentSpace.use(\n                    new IdleMonitorPlugin(\n                        this.decisionOptions.idleKickTimeoutMs ?? 60_000,\n                        10_000\n                    )\n                );\n            }\n\n            this.isSpaceRunning = true;\n            await this.scraper.sendTweet(\n                broadcastInfo.share_url.replace(\"broadcasts\", \"spaces\")\n            );\n\n            const spaceUrl = broadcastInfo.share_url.replace(\n                \"broadcasts\",\n                \"spaces\"\n            );\n            elizaLogger.log(`[Space] Space started => ${spaceUrl}`);\n\n            // Greet\n            await speakFiller(\n                this.client.runtime,\n                this.sttTtsPlugin,\n                \"WELCOME\"\n            );\n\n            // Events\n            this.currentSpace.on(\"occupancyUpdate\", (update) => {\n                elizaLogger.log(\n                    `[Space] Occupancy => ${update.occupancy} participant(s).`\n                );\n            });\n\n            this.currentSpace.on(\n                \"speakerRequest\",\n                async (req: SpeakerRequest) => {\n                    elizaLogger.log(\n                        `[Space] Speaker request from @${req.username} (${req.userId}).`\n                    );\n                    await this.handleSpeakerRequest(req);\n                }\n            );\n\n            this.currentSpace.on(\"idleTimeout\", async (info) => {\n                elizaLogger.log(\n                    `[Space] idleTimeout => no audio for ${info.idleMs} ms.`\n                );\n                await speakFiller(\n                    this.client.runtime,\n                    this.sttTtsPlugin,\n                    \"IDLE_ENDING\"\n                );\n                await this.stopSpace();\n            });\n\n            process.on(\"SIGINT\", async () => {\n                elizaLogger.log(\"[Space] SIGINT => stopping space\");\n                await speakFiller(\n                    this.client.runtime,\n                    this.sttTtsPlugin,\n                    \"CLOSING\"\n                );\n                await this.stopSpace();\n                process.exit(0);\n            });\n        } catch (error) {\n            elizaLogger.error(\"[Space] Error launching Space =>\", error);\n            this.isSpaceRunning = false;\n            throw error;\n        }\n    }\n\n    /**\n     * Periodic management: check durations, remove extras, maybe accept new from queue\n     */\n    private async manageCurrentSpace() {\n        if (!this.spaceId || !this.currentSpace) return;\n        try {\n            const audioSpace = await this.scraper.getAudioSpaceById(\n                this.spaceId\n            );\n            const { participants } = audioSpace;\n            const numSpeakers = participants.speakers?.length || 0;\n            const totalListeners = participants.listeners?.length || 0;\n\n            // 1) Remove any speaker who exceeded speakerMaxDurationMs\n            const maxDur = this.decisionOptions.speakerMaxDurationMs ?? 240_000;\n            const now = Date.now();\n\n            for (let i = this.activeSpeakers.length - 1; i >= 0; i--) {\n                const speaker = this.activeSpeakers[i];\n                const elapsed = now - speaker.startTime;\n                if (elapsed > maxDur) {\n                    elizaLogger.log(\n                        `[Space] Speaker @${speaker.username} exceeded max duration => removing`\n                    );\n                    await this.removeSpeaker(speaker.userId);\n                    this.activeSpeakers.splice(i, 1);\n\n                    // Possibly speak a short \"SPEAKER_LEFT\" filler\n                    await speakFiller(\n                        this.client.runtime,\n                        this.sttTtsPlugin,\n                        \"SPEAKER_LEFT\"\n                    );\n                }\n            }\n\n            // 2) If we have capacity for new speakers from the queue, accept them\n            await this.acceptSpeakersFromQueueIfNeeded();\n\n            // 3) If somehow more than maxSpeakers are active, remove the extras\n            if (numSpeakers > (this.decisionOptions.maxSpeakers ?? 1)) {\n                elizaLogger.log(\n                    \"[Space] More than maxSpeakers => removing extras...\"\n                );\n                await this.kickExtraSpeakers(participants.speakers);\n            }\n\n            // 4) Possibly stop the space if empty or time exceeded\n            const elapsedMinutes = (now - (this.startedAt || 0)) / 60000;\n            if (\n                elapsedMinutes >\n                    (this.decisionOptions.typicalDurationMinutes ?? 30) ||\n                (numSpeakers === 0 &&\n                    totalListeners === 0 &&\n                    elapsedMinutes > 5)\n            ) {\n                elizaLogger.log(\n                    \"[Space] Condition met => stopping the Space...\"\n                );\n                await speakFiller(\n                    this.client.runtime,\n                    this.sttTtsPlugin,\n                    \"CLOSING\",\n                    4000\n                );\n                await this.stopSpace();\n            }\n        } catch (error) {\n            elizaLogger.error(\"[Space] Error in manageCurrentSpace =>\", error);\n        }\n    }\n\n    /**\n     * If we have available slots, accept new speakers from the queue\n     */\n    private async acceptSpeakersFromQueueIfNeeded() {\n        // while queue not empty and activeSpeakers < maxSpeakers, accept next\n        const ms = this.decisionOptions.maxSpeakers ?? 1;\n        while (\n            this.speakerQueue.length > 0 &&\n            this.activeSpeakers.length < ms\n        ) {\n            const nextReq = this.speakerQueue.shift();\n            if (nextReq) {\n                await speakFiller(\n                    this.client.runtime,\n                    this.sttTtsPlugin,\n                    \"PRE_ACCEPT\"\n                );\n                await this.acceptSpeaker(nextReq);\n            }\n        }\n    }\n\n    private async handleSpeakerRequest(req: SpeakerRequest) {\n        if (!this.spaceId || !this.currentSpace) return;\n\n        const audioSpace = await this.scraper.getAudioSpaceById(this.spaceId);\n        const janusSpeakers = audioSpace?.participants?.speakers || [];\n\n        // If we haven't reached maxSpeakers, accept immediately\n        if (janusSpeakers.length < (this.decisionOptions.maxSpeakers ?? 1)) {\n            elizaLogger.log(`[Space] Accepting speaker @${req.username} now`);\n            await speakFiller(\n                this.client.runtime,\n                this.sttTtsPlugin,\n                \"PRE_ACCEPT\"\n            );\n            await this.acceptSpeaker(req);\n        } else {\n            elizaLogger.log(\n                `[Space] Adding speaker @${req.username} to the queue`\n            );\n            this.speakerQueue.push(req);\n        }\n    }\n\n    private async acceptSpeaker(req: SpeakerRequest) {\n        if (!this.currentSpace) return;\n        try {\n            await this.currentSpace.approveSpeaker(req.userId, req.sessionUUID);\n            this.activeSpeakers.push({\n                userId: req.userId,\n                sessionUUID: req.sessionUUID,\n                username: req.username,\n                startTime: Date.now(),\n            });\n            elizaLogger.log(`[Space] Speaker @${req.username} is now live`);\n        } catch (err) {\n            elizaLogger.error(\n                `[Space] Error approving speaker @${req.username}:`,\n                err\n            );\n        }\n    }\n\n    private async removeSpeaker(userId: string) {\n        if (!this.currentSpace) return;\n        try {\n            await this.currentSpace.removeSpeaker(userId);\n            elizaLogger.log(`[Space] Removed speaker userId=${userId}`);\n        } catch (error) {\n            elizaLogger.error(\n                `[Space] Error removing speaker userId=${userId} =>`,\n                error\n            );\n        }\n    }\n\n    /**\n     * If more than maxSpeakers are found, remove extras\n     * Also update activeSpeakers array\n     */\n    private async kickExtraSpeakers(speakers: any[]) {\n        if (!this.currentSpace) return;\n        const ms = this.decisionOptions.maxSpeakers ?? 1;\n\n        // sort by who joined first if needed, or just slice\n        const extras = speakers.slice(ms);\n        for (const sp of extras) {\n            elizaLogger.log(\n                `[Space] Removing extra speaker => userId=${sp.user_id}`\n            );\n            await this.removeSpeaker(sp.user_id);\n\n            // remove from activeSpeakers array\n            const idx = this.activeSpeakers.findIndex(\n                (s) => s.userId === sp.user_id\n            );\n            if (idx !== -1) {\n                this.activeSpeakers.splice(idx, 1);\n            }\n        }\n    }\n\n    public async stopSpace() {\n        if (!this.currentSpace || !this.isSpaceRunning) return;\n        try {\n            elizaLogger.log(\"[Space] Stopping the current Space...\");\n            await this.currentSpace.stop();\n        } catch (err) {\n            elizaLogger.error(\"[Space] Error stopping Space =>\", err);\n        } finally {\n            this.isSpaceRunning = false;\n            this.spaceId = undefined;\n            this.currentSpace = undefined;\n            this.startedAt = undefined;\n            this.lastSpaceEndedAt = Date.now();\n            this.activeSpeakers = [];\n            this.speakerQueue = [];\n        }\n    }\n}\n","// src/plugins/SttTtsPlugin.ts\n\nimport { spawn } from \"child_process\";\nimport {\n    type ITranscriptionService,\n    elizaLogger,\n    stringToUuid,\n    composeContext,\n    getEmbeddingZeroVector,\n    generateMessageResponse,\n    ModelClass,\n    type Content,\n    type IAgentRuntime,\n    type Memory,\n    type Plugin,\n    type UUID,\n    type State,\n    composeRandomUser,\n    generateShouldRespond,\n} from \"@elizaos/core\";\nimport type {\n    Space,\n    JanusClient,\n    AudioDataWithUser,\n} from \"agent-twitter-client\";\nimport type { ClientBase } from \"../base\";\nimport {\n    twitterVoiceHandlerTemplate,\n    twitterShouldRespondTemplate,\n} from \"./templates\";\n\ninterface PluginConfig {\n    runtime: IAgentRuntime;\n    client: ClientBase;\n    spaceId: string;\n    elevenLabsApiKey?: string; // for TTS\n    sttLanguage?: string; // e.g. \"en\" for Whisper\n    silenceThreshold?: number; // amplitude threshold for ignoring silence\n    voiceId?: string; // specify which ElevenLabs voice to use\n    elevenLabsModel?: string; // e.g. \"eleven_monolingual_v1\"\n    chatContext?: Array<{\n        role: \"system\" | \"user\" | \"assistant\";\n        content: string;\n    }>;\n    transcriptionService: ITranscriptionService;\n}\n\nconst VOLUME_WINDOW_SIZE = 100;\nconst SPEAKING_THRESHOLD = 0.05;\nconst SILENCE_DETECTION_THRESHOLD_MS = 1000; // 1-second silence threshold\n\n/**\n * MVP plugin for speech-to-text (OpenAI) + conversation + TTS (ElevenLabs)\n * Approach:\n *   - Collect each speaker's unmuted PCM in a memory buffer (only if above silence threshold)\n *   - On speaker mute -> flush STT -> GPT -> TTS -> push to Janus\n */\nexport class SttTtsPlugin implements Plugin {\n    name = \"SttTtsPlugin\";\n    description = \"Speech-to-text (OpenAI) + conversation + TTS (ElevenLabs)\";\n    private runtime: IAgentRuntime;\n    private client: ClientBase;\n    private spaceId: string;\n\n    private space?: Space;\n    private janus?: JanusClient;\n\n    private elevenLabsApiKey?: string;\n\n    private voiceId = \"21m00Tcm4TlvDq8ikWAM\";\n    private elevenLabsModel = \"eleven_monolingual_v1\";\n    private chatContext: Array<{\n        role: \"system\" | \"user\" | \"assistant\";\n        content: string;\n    }> = [];\n\n    private transcriptionService: ITranscriptionService;\n\n    /**\n     * userId => arrayOfChunks (PCM Int16)\n     */\n    private pcmBuffers = new Map<string, Int16Array[]>();\n\n    /**\n     * For ignoring near-silence frames (if amplitude < threshold)\n     */\n    private silenceThreshold = 50;\n\n    // TTS queue for sequentially speaking\n    private ttsQueue: string[] = [];\n    private isSpeaking = false;\n    private isProcessingAudio = false;\n\n    private userSpeakingTimer: NodeJS.Timeout | null = null;\n    private volumeBuffers: Map<string, number[]>;\n    private ttsAbortController: AbortController | null = null;\n\n    onAttach(_space: Space) {\n        elizaLogger.log(\"[SttTtsPlugin] onAttach => space was attached\");\n    }\n\n    init(params: { space: Space; pluginConfig?: Record<string, any> }): void {\n        elizaLogger.log(\n            \"[SttTtsPlugin] init => Space fully ready. Subscribing to events.\",\n        );\n\n        this.space = params.space;\n        this.janus = (this.space as any)?.janusClient as\n            | JanusClient\n            | undefined;\n\n        const config = params.pluginConfig as PluginConfig;\n        this.runtime = config?.runtime;\n        this.client = config?.client;\n        this.spaceId = config?.spaceId;\n        this.elevenLabsApiKey = config?.elevenLabsApiKey;\n        this.transcriptionService = config.transcriptionService;\n        if (typeof config?.silenceThreshold === \"number\") {\n            this.silenceThreshold = config.silenceThreshold;\n        }\n        if (config?.voiceId) {\n            this.voiceId = config.voiceId;\n        }\n        if (config?.elevenLabsModel) {\n            this.elevenLabsModel = config.elevenLabsModel;\n        }\n        if (config?.chatContext) {\n            this.chatContext = config.chatContext;\n        }\n\n        this.volumeBuffers = new Map<string, number[]>();\n    }\n\n    /**\n     * Called whenever we receive PCM from a speaker\n     */\n    onAudioData(data: AudioDataWithUser): void {\n        if (this.isProcessingAudio) {\n            return;\n        }\n        let maxVal = 0;\n        for (let i = 0; i < data.samples.length; i++) {\n            const val = Math.abs(data.samples[i]);\n            if (val > maxVal) maxVal = val;\n        }\n        if (maxVal < this.silenceThreshold) {\n            return;\n        }\n\n        if (this.userSpeakingTimer) {\n            clearTimeout(this.userSpeakingTimer);\n        }\n\n        let arr = this.pcmBuffers.get(data.userId);\n        if (!arr) {\n            arr = [];\n            this.pcmBuffers.set(data.userId, arr);\n        }\n        arr.push(data.samples);\n\n        if (!this.isSpeaking) {\n            this.userSpeakingTimer = setTimeout(() => {\n                elizaLogger.log(\n                    \"[SttTtsPlugin] start processing audio for user =>\",\n                    data.userId,\n                );\n                this.userSpeakingTimer = null;\n                this.processAudio(data.userId).catch((err) =>\n                    elizaLogger.error(\n                        \"[SttTtsPlugin] handleSilence error =>\",\n                        err,\n                    ),\n                );\n            }, SILENCE_DETECTION_THRESHOLD_MS);\n        } else {\n            // check interruption\n            let volumeBuffer = this.volumeBuffers.get(data.userId);\n            if (!volumeBuffer) {\n                volumeBuffer = [];\n                this.volumeBuffers.set(data.userId, volumeBuffer);\n            }\n            const samples = new Int16Array(\n                data.samples.buffer,\n                data.samples.byteOffset,\n                data.samples.length / 2,\n            );\n            const maxAmplitude = Math.max(...samples.map(Math.abs)) / 32768;\n            volumeBuffer.push(maxAmplitude);\n\n            if (volumeBuffer.length > VOLUME_WINDOW_SIZE) {\n                volumeBuffer.shift();\n            }\n            const avgVolume =\n                volumeBuffer.reduce((sum, v) => sum + v, 0) /\n                VOLUME_WINDOW_SIZE;\n\n            if (avgVolume > SPEAKING_THRESHOLD) {\n                volumeBuffer.length = 0;\n                if (this.ttsAbortController) {\n                    this.ttsAbortController.abort();\n                    this.isSpeaking = false;\n                    elizaLogger.log(\"[SttTtsPlugin] TTS playback interrupted\");\n                }\n            }\n        }\n    }\n\n    // /src/sttTtsPlugin.ts\n    private async convertPcmToWavInMemory(\n        pcmData: Int16Array,\n        sampleRate: number,\n    ): Promise<ArrayBuffer> {\n        // number of channels\n        const numChannels = 1;\n        // byte rate = (sampleRate * numChannels * bitsPerSample/8)\n        const byteRate = sampleRate * numChannels * 2;\n        const blockAlign = numChannels * 2;\n        // data chunk size = pcmData.length * (bitsPerSample/8)\n        const dataSize = pcmData.length * 2;\n\n        // WAV header is 44 bytes\n        const buffer = new ArrayBuffer(44 + dataSize);\n        const view = new DataView(buffer);\n\n        // RIFF chunk descriptor\n        this.writeString(view, 0, \"RIFF\");\n        view.setUint32(4, 36 + dataSize, true); // file size - 8\n        this.writeString(view, 8, \"WAVE\");\n\n        // fmt sub-chunk\n        this.writeString(view, 12, \"fmt \");\n        view.setUint32(16, 16, true); // Subchunk1Size (16 for PCM)\n        view.setUint16(20, 1, true); // AudioFormat (1 = PCM)\n        view.setUint16(22, numChannels, true); // NumChannels\n        view.setUint32(24, sampleRate, true); // SampleRate\n        view.setUint32(28, byteRate, true); // ByteRate\n        view.setUint16(32, blockAlign, true); // BlockAlign\n        view.setUint16(34, 16, true); // BitsPerSample (16)\n\n        // data sub-chunk\n        this.writeString(view, 36, \"data\");\n        view.setUint32(40, dataSize, true);\n\n        // Write PCM samples\n        let offset = 44;\n        for (let i = 0; i < pcmData.length; i++, offset += 2) {\n            view.setInt16(offset, pcmData[i], true);\n        }\n\n        return buffer;\n    }\n\n    private writeString(view: DataView, offset: number, text: string) {\n        for (let i = 0; i < text.length; i++) {\n            view.setUint8(offset + i, text.charCodeAt(i));\n        }\n    }\n\n    /**\n     * On speaker silence => flush STT => GPT => TTS => push to Janus\n     */\n    private async processAudio(userId: string): Promise<void> {\n        if (this.isProcessingAudio) {\n            return;\n        }\n        this.isProcessingAudio = true;\n        try {\n            elizaLogger.log(\n                \"[SttTtsPlugin] Starting audio processing for user:\",\n                userId,\n            );\n            const chunks = this.pcmBuffers.get(userId) || [];\n            this.pcmBuffers.clear();\n\n            if (!chunks.length) {\n                elizaLogger.warn(\n                    \"[SttTtsPlugin] No audio chunks for user =>\",\n                    userId,\n                );\n                return;\n            }\n            elizaLogger.log(\n                `[SttTtsPlugin] Flushing STT buffer for user=${userId}, chunks=${chunks.length}`,\n            );\n\n            const totalLen = chunks.reduce((acc, c) => acc + c.length, 0);\n            const merged = new Int16Array(totalLen);\n            let offset = 0;\n            for (const c of chunks) {\n                merged.set(c, offset);\n                offset += c.length;\n            }\n\n            // Convert PCM to WAV for STT\n            const wavBuffer = await this.convertPcmToWavInMemory(merged, 48000);\n\n            // Whisper STT\n            const sttText =\n                await this.transcriptionService.transcribe(wavBuffer);\n\n            elizaLogger.log(\n                `[SttTtsPlugin] Transcription result: \"${sttText}\"`,\n            );\n\n            if (!sttText || !sttText.trim()) {\n                elizaLogger.warn(\n                    \"[SttTtsPlugin] No speech recognized for user =>\",\n                    userId,\n                );\n                return;\n            }\n            elizaLogger.log(\n                `[SttTtsPlugin] STT => user=${userId}, text=\"${sttText}\"`,\n            );\n\n            // Get response\n            const replyText = await this.handleUserMessage(sttText, userId);\n            if (!replyText || !replyText.length || !replyText.trim()) {\n                elizaLogger.warn(\n                    \"[SttTtsPlugin] No replyText for user =>\",\n                    userId,\n                );\n                return;\n            }\n            elizaLogger.log(\n                `[SttTtsPlugin] user=${userId}, reply=\"${replyText}\"`,\n            );\n            this.isProcessingAudio = false;\n            this.volumeBuffers.clear();\n            // Use the standard speak method with queue\n            await this.speakText(replyText);\n        } catch (error) {\n            elizaLogger.error(\"[SttTtsPlugin] processAudio error =>\", error);\n        } finally {\n            this.isProcessingAudio = false;\n        }\n    }\n\n    /**\n     * Public method to queue a TTS request\n     */\n    public async speakText(text: string): Promise<void> {\n        this.ttsQueue.push(text);\n        if (!this.isSpeaking) {\n            this.isSpeaking = true;\n            this.processTtsQueue().catch((err) => {\n                elizaLogger.error(\n                    \"[SttTtsPlugin] processTtsQueue error =>\",\n                    err,\n                );\n            });\n        }\n    }\n\n    /**\n     * Process TTS requests one by one\n     */\n    private async processTtsQueue(): Promise<void> {\n        while (this.ttsQueue.length > 0) {\n            const text = this.ttsQueue.shift();\n            if (!text) continue;\n\n            this.ttsAbortController = new AbortController();\n            const { signal } = this.ttsAbortController;\n\n            try {\n                const ttsAudio = await this.elevenLabsTts(text);\n                const pcm = await this.convertMp3ToPcm(ttsAudio, 48000);\n                if (signal.aborted) {\n                    elizaLogger.log(\n                        \"[SttTtsPlugin] TTS interrupted before streaming\",\n                    );\n                    return;\n                }\n                await this.streamToJanus(pcm, 48000);\n                if (signal.aborted) {\n                    elizaLogger.log(\n                        \"[SttTtsPlugin] TTS interrupted after streaming\",\n                    );\n                    return;\n                }\n            } catch (err) {\n                elizaLogger.error(\"[SttTtsPlugin] TTS streaming error =>\", err);\n            } finally {\n                // Clean up the AbortController\n                this.ttsAbortController = null;\n            }\n        }\n        this.isSpeaking = false;\n    }\n\n    /**\n     * Handle User Message\n     */\n    private async handleUserMessage(\n        userText: string,\n        userId: string, // This is the raw Twitter user ID like 'tw-1865462035586142208'\n    ): Promise<string> {\n        // Extract the numeric ID part\n        const numericId = userId.replace(\"tw-\", \"\");\n        const roomId = stringToUuid(`twitter_generate_room-${this.spaceId}`);\n\n        // Create consistent UUID for the user\n        const userUuid = stringToUuid(`twitter-user-${numericId}`);\n\n        // Ensure the user exists in the accounts table\n        await this.runtime.ensureUserExists(\n            userUuid,\n            userId, // Use full Twitter ID as username\n            `Twitter User ${numericId}`,\n            \"twitter\",\n        );\n\n        // Ensure room exists and user is in it\n        await this.runtime.ensureRoomExists(roomId);\n        await this.runtime.ensureParticipantInRoom(userUuid, roomId);\n\n        let state = await this.runtime.composeState(\n            {\n                agentId: this.runtime.agentId,\n                content: { text: userText, source: \"twitter\" },\n                userId: userUuid,\n                roomId,\n            },\n            {\n                twitterUserName: this.client.profile.username,\n                agentName: this.runtime.character.name,\n            },\n        );\n\n        const memory = {\n            id: stringToUuid(`${roomId}-voice-message-${Date.now()}`),\n            agentId: this.runtime.agentId,\n            content: {\n                text: userText,\n                source: \"twitter\",\n            },\n            userId: userUuid,\n            roomId,\n            embedding: getEmbeddingZeroVector(),\n            createdAt: Date.now(),\n        };\n\n        await this.runtime.messageManager.createMemory(memory);\n\n        state = await this.runtime.updateRecentMessageState(state);\n\n        const shouldIgnore = await this._shouldIgnore(memory);\n\n        if (shouldIgnore) {\n            return \"\";\n        }\n\n        const shouldRespond = await this._shouldRespond(userText, state);\n\n        if (!shouldRespond) {\n            return \"\";\n        }\n\n        const context = composeContext({\n            state,\n            template:\n                this.runtime.character.templates?.twitterVoiceHandlerTemplate ||\n                this.runtime.character.templates?.messageHandlerTemplate ||\n                twitterVoiceHandlerTemplate,\n        });\n\n        const responseContent = await this._generateResponse(memory, context);\n\n        const responseMemory: Memory = {\n            id: stringToUuid(`${memory.id}-voice-response-${Date.now()}`),\n            agentId: this.runtime.agentId,\n            userId: this.runtime.agentId,\n            content: {\n                ...responseContent,\n                user: this.runtime.character.name,\n                inReplyTo: memory.id,\n            },\n            roomId,\n            embedding: getEmbeddingZeroVector(),\n        };\n\n        const reply = responseMemory.content.text?.trim();\n        if (reply) {\n            await this.runtime.messageManager.createMemory(responseMemory);\n        }\n\n        return reply;\n    }\n\n    private async _generateResponse(\n        message: Memory,\n        context: string,\n    ): Promise<Content> {\n        const { userId, roomId } = message;\n\n        const response = await generateMessageResponse({\n            runtime: this.runtime,\n            context,\n            modelClass: ModelClass.SMALL,\n        });\n\n        response.source = \"discord\";\n\n        if (!response) {\n            elizaLogger.error(\n                \"[SttTtsPlugin] No response from generateMessageResponse\",\n            );\n            return;\n        }\n\n        await this.runtime.databaseAdapter.log({\n            body: { message, context, response },\n            userId: userId,\n            roomId,\n            type: \"response\",\n        });\n\n        return response;\n    }\n\n    private async _shouldIgnore(message: Memory): Promise<boolean> {\n        elizaLogger.debug(\"message.content: \", message.content);\n        // if the message is 3 characters or less, ignore it\n        if ((message.content as Content).text.length < 3) {\n            return true;\n        }\n\n        const loseInterestWords = [\n            // telling the bot to stop talking\n            \"shut up\",\n            \"stop\",\n            \"dont talk\",\n            \"silence\",\n            \"stop talking\",\n            \"be quiet\",\n            \"hush\",\n            \"stfu\",\n            \"stupid bot\",\n            \"dumb bot\",\n\n            // offensive words\n            \"fuck\",\n            \"shit\",\n            \"damn\",\n            \"suck\",\n            \"dick\",\n            \"cock\",\n            \"sex\",\n            \"sexy\",\n        ];\n        if (\n            (message.content as Content).text.length < 50 &&\n            loseInterestWords.some((word) =>\n                (message.content as Content).text?.toLowerCase().includes(word),\n            )\n        ) {\n            return true;\n        }\n\n        const ignoreWords = [\"k\", \"ok\", \"bye\", \"lol\", \"nm\", \"uh\"];\n        if (\n            (message.content as Content).text?.length < 8 &&\n            ignoreWords.some((word) =>\n                (message.content as Content).text?.toLowerCase().includes(word),\n            )\n        ) {\n            return true;\n        }\n\n        return false;\n    }\n\n    private async _shouldRespond(\n        message: string,\n        state: State,\n    ): Promise<boolean> {\n        const lowerMessage = message.toLowerCase();\n        const characterName = this.runtime.character.name.toLowerCase();\n\n        if (lowerMessage.includes(characterName)) {\n            return true;\n        }\n\n        // If none of the above conditions are met, use the generateText to decide\n        const shouldRespondContext = composeContext({\n            state,\n            template:\n                this.runtime.character.templates\n                    ?.twitterShouldRespondTemplate ||\n                this.runtime.character.templates?.shouldRespondTemplate ||\n                composeRandomUser(twitterShouldRespondTemplate, 2),\n        });\n\n        const response = await generateShouldRespond({\n            runtime: this.runtime,\n            context: shouldRespondContext,\n            modelClass: ModelClass.SMALL,\n        });\n\n        if (response === \"RESPOND\") {\n            return true;\n        }\n\n        if (response === \"IGNORE\" || response === \"STOP\") {\n            return false;\n        }\n\n        elizaLogger.error(\n            \"Invalid response from response generateText:\",\n            response,\n        );\n        return false;\n    }\n\n    /**\n     * ElevenLabs TTS => returns MP3 Buffer\n     */\n    private async elevenLabsTts(text: string): Promise<Buffer> {\n        if (!this.elevenLabsApiKey) {\n            throw new Error(\"[SttTtsPlugin] No ElevenLabs API key\");\n        }\n        const url = `https://api.elevenlabs.io/v1/text-to-speech/${this.voiceId}`;\n        const resp = await fetch(url, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                \"xi-api-key\": this.elevenLabsApiKey,\n            },\n            body: JSON.stringify({\n                text,\n                model_id: this.elevenLabsModel,\n                voice_settings: { stability: 0.4, similarity_boost: 0.8 },\n            }),\n        });\n        if (!resp.ok) {\n            const errText = await resp.text();\n            throw new Error(\n                `[SttTtsPlugin] ElevenLabs TTS error => ${resp.status} ${errText}`,\n            );\n        }\n        const arrayBuf = await resp.arrayBuffer();\n        return Buffer.from(arrayBuf);\n    }\n\n    /**\n     * Convert MP3 => PCM via ffmpeg\n     */\n    private convertMp3ToPcm(\n        mp3Buf: Buffer,\n        outRate: number,\n    ): Promise<Int16Array> {\n        return new Promise((resolve, reject) => {\n            const ff = spawn(\"ffmpeg\", [\n                \"-i\",\n                \"pipe:0\",\n                \"-f\",\n                \"s16le\",\n                \"-ar\",\n                outRate.toString(),\n                \"-ac\",\n                \"1\",\n                \"pipe:1\",\n            ]);\n            let raw = Buffer.alloc(0);\n\n            ff.stdout.on(\"data\", (chunk: Buffer) => {\n                raw = Buffer.concat([raw, chunk]);\n            });\n            ff.stderr.on(\"data\", () => {\n                // ignoring ffmpeg logs\n            });\n            ff.on(\"close\", (code) => {\n                if (code !== 0) {\n                    reject(new Error(`ffmpeg error code=${code}`));\n                    return;\n                }\n                const samples = new Int16Array(\n                    raw.buffer,\n                    raw.byteOffset,\n                    raw.byteLength / 2,\n                );\n                resolve(samples);\n            });\n\n            ff.stdin.write(mp3Buf);\n            ff.stdin.end();\n        });\n    }\n\n    /**\n     * Push PCM back to Janus in small frames\n     * We'll do 10ms @48k => 960 samples per frame\n     */\n    private async streamToJanus(\n        samples: Int16Array,\n        sampleRate: number,\n    ): Promise<void> {\n        // TODO: Check if better than 480 fixed\n        const FRAME_SIZE = Math.floor(sampleRate * 0.01); // 10ms frames => 480 @48kHz\n\n        for (\n            let offset = 0;\n            offset + FRAME_SIZE <= samples.length;\n            offset += FRAME_SIZE\n        ) {\n            if (this.ttsAbortController?.signal.aborted) {\n                elizaLogger.log(\"[SttTtsPlugin] streamToJanus interrupted\");\n                return;\n            }\n            const frame = new Int16Array(FRAME_SIZE);\n            frame.set(samples.subarray(offset, offset + FRAME_SIZE));\n            this.janus?.pushLocalAudio(frame, sampleRate, 1);\n\n            // Short pause so we don't overload\n            await new Promise((r) => setTimeout(r, 10));\n        }\n    }\n\n    /**\n     * Add a message (system, user or assistant) to the chat context.\n     * E.g. to store conversation history or inject a persona.\n     */\n    public addMessage(role: \"system\" | \"user\" | \"assistant\", content: string) {\n        this.chatContext.push({ role, content });\n        elizaLogger.log(\n            `[SttTtsPlugin] addMessage => role=${role}, content=${content}`,\n        );\n    }\n\n    /**\n     * Clear the chat context if needed.\n     */\n    public clearChatContext() {\n        this.chatContext = [];\n        elizaLogger.log(\"[SttTtsPlugin] clearChatContext => done\");\n    }\n\n    cleanup(): void {\n        elizaLogger.log(\"[SttTtsPlugin] cleanup => releasing resources\");\n        this.pcmBuffers.clear();\n        this.userSpeakingTimer = null;\n        this.ttsQueue = [];\n        this.isSpeaking = false;\n        this.volumeBuffers.clear();\n    }\n}\n","import { messageCompletionFooter, shouldRespondFooter } from \"@elizaos/core\";\n\nexport const twitterShouldRespondTemplate =\n    `# Task: Decide if {{agentName}} should respond.\nAbout {{agentName}}:\n{{bio}}\n\n# INSTRUCTIONS: Determine if {{agentName}} should respond to the message and participate in the conversation. Do not comment. Just respond with \"RESPOND\" or \"IGNORE\" or \"STOP\".\n\n# RESPONSE EXAMPLES\n{{user1}}: I just saw a really great movie\n{{user2}}: Oh? Which movie?\nResult: [IGNORE]\n\n{{agentName}}: Oh, this is my favorite scene\n{{user1}}: sick\n{{user2}}: wait, why is it your favorite scene\nResult: [RESPOND]\n\n{{user1}}: stfu bot\nResult: [STOP]\n\n{{user1}}: Hey {{agent}}, can you help me with something\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} stfu plz\nResult: [STOP]\n\n{{user1}}: i need help\n{{agentName}}: how can I help you?\n{{user1}}: no. i need help from someone else\nResult: [IGNORE]\n\n{{user1}}: Hey {{agent}}, can I ask you a question\n{{agentName}}: Sure, what is it\n{{user1}}: can you ask claude to create a basic react module that demonstrates a counter\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} can you tell me a story\n{{user1}}: about a girl named elara\n{{agentName}}: Sure.\n{{agentName}}: Once upon a time, in a quaint little village, there was a curious girl named Elara.\n{{agentName}}: Elara was known for her adventurous spirit and her knack for finding beauty in the mundane.\n{{user1}}: I'm loving it, keep going\nResult: [RESPOND]\n\n{{user1}}: {{agentName}} stop responding plz\nResult: [STOP]\n\n{{user1}}: okay, i want to test something. can you say marco?\n{{agentName}}: marco\n{{user1}}: great. okay, now do it again\nResult: [RESPOND]\n\nResponse options are [RESPOND], [IGNORE] and [STOP].\n\n{{agentName}} is in a room with other users and is very worried about being annoying and saying too much.\nRespond with [RESPOND] to messages that are directed at {{agentName}}, or participate in conversations that are interesting or relevant to their background.\nIf a message is not interesting or relevant, respond with [IGNORE]\nUnless directly responding to a user, respond with [IGNORE] to messages that are very short or do not contain much information.\nIf a user asks {{agentName}} to be quiet, respond with [STOP]\nIf {{agentName}} concludes a conversation and isn't part of the conversation anymore, respond with [STOP]\n\nIMPORTANT: {{agentName}} is particularly sensitive about being annoying, so if there is any doubt, it is better to respond with [IGNORE].\nIf {{agentName}} is conversing with a user and they have not asked to stop, it is better to respond with [RESPOND].\n\n{{recentMessages}}\n\n# INSTRUCTIONS: Choose the option that best describes {{agentName}}'s response to the last message. Ignore messages if they are addressed to someone else.\n` + shouldRespondFooter;\n\nexport const twitterVoiceHandlerTemplate =\n    `# Task: Generate conversational voice dialog for {{agentName}}.\n    About {{agentName}}:\n    {{bio}}\n\n    # Attachments\n    {{attachments}}\n\n    # Capabilities\n    Note that {{agentName}} is capable of reading/seeing/hearing various forms of media, including images, videos, audio, plaintext and PDFs. Recent attachments have been included above under the \"Attachments\" section.\n\n    {{actions}}\n\n    {{messageDirections}}\n\n    {{recentMessages}}\n\n    # Instructions: Write the next message for {{agentName}}. Include an optional action if appropriate. {{actionNames}}\n    ` + messageCompletionFooter;\n","import { TwitterClientInterface } from \"./client\";\n\nconst twitterPlugin = {\n    name: \"twitter\",\n    description: \"Twitter client\",\n    clients: [TwitterClientInterface],\n};\nexport default twitterPlugin;\n"],"mappings":"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","names":["elizaLogger","authToken","ct0","guestId","existingMemories","existingMemoryIds","tweetsToSave","profile","ActionTimelineType","SearchMode","stringToUuid","elizaLogger","getEmbeddingZeroVector","getEmbeddingZeroVector","stringToUuid","elizaLogger","elizaLogger","stringToUuid","getEmbeddingZeroVector","elizaLogger","SearchMode","stringToUuid","tweet","message","response","tweetId","getEmbeddingZeroVector","composeContext","getEmbeddingZeroVector","ModelClass","stringToUuid","elizaLogger","ServiceType","elizaLogger","stringToUuid","getEmbeddingZeroVector","composeContext","ModelClass","ServiceType","SearchMode","composeContext","elizaLogger","generateMessageResponse","generateText","messageCompletionFooter","ModelClass","ServiceType","stringToUuid","messageCompletionFooter","elizaLogger","SearchMode","generateText","ModelClass","stringToUuid","ServiceType","composeContext","generateMessageResponse","response","elizaLogger","composeContext","generateText","ModelClass","ServiceType","elizaLogger","stringToUuid","composeContext","getEmbeddingZeroVector","generateMessageResponse","ModelClass","generateShouldRespond","messageCompletionFooter","shouldRespondFooter","twitterShouldRespondTemplate","elizaLogger","stringToUuid","getEmbeddingZeroVector","composeContext","generateMessageResponse","ModelClass","_a","twitterShouldRespondTemplate","generateShouldRespond","composeContext","generateText","ModelClass","elizaLogger","ServiceType","elizaLogger"]}